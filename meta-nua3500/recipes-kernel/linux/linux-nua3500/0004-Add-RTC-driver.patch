From cb1aa5ff1b0d4ead642d00995b944e4e412924ce Mon Sep 17 00:00:00 2001
From: mjchen <mjchen@nuvoton.com>
Date: Tue, 21 Jul 2020 13:19:21 +0800
Subject: [PATCH 4/7] Add RTC driver

Change-Id: I04c1719d26b55caadd3c8b3cdcb92ef4a3bd8fb8
---
 arch/arm64/configs/nua3500_defconfig |  62 +++++-
 drivers/rtc/Kconfig                  |   6 +
 drivers/rtc/Makefile                 |   3 +
 drivers/rtc/rtc-nua3500.c            | 417 +++++++++++++++++++++++++++++++++++
 include/uapi/linux/rtc.h             |   3 +
 5 files changed, 490 insertions(+), 1 deletion(-)
 create mode 100644 drivers/rtc/rtc-nua3500.c

diff --git a/arch/arm64/configs/nua3500_defconfig b/arch/arm64/configs/nua3500_defconfig
index 52c429a..aa46db7 100755
--- a/arch/arm64/configs/nua3500_defconfig
+++ b/arch/arm64/configs/nua3500_defconfig
@@ -1458,7 +1458,67 @@ CONFIG_MMC_SDHCI_OF_DWCMSHC=y
 # CONFIG_ACCESSIBILITY is not set
 # CONFIG_INFINIBAND is not set
 CONFIG_EDAC_SUPPORT=y
-# CONFIG_RTC_CLASS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+# CONFIG_RTC_SYSTOHC is not set
+# CONFIG_RTC_DEBUG is not set
+# CONFIG_RTC_NVMEM is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+
+#
+# SPI RTC drivers
+#
+
+#
+# SPI and I2C RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_CADENCE is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+CONFIG_RTC_DRV_NUA3500=y
+
+#
+# HID Sensor RTC drivers
+#
 # CONFIG_DMADEVICES is not set
 
 #
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index c5b9804..773b16f 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1870,6 +1870,12 @@ config RTC_DRV_STM32
 	   This driver can also be built as a module, if so, the module
 	   will be called "rtc-stm32".
 
+config RTC_DRV_NUA3500
+	tristate "NUA3500 RTC driver"
+	help
+	  If you say yes here you get support for the RTC subsystem of the
+	  NUA3500 used in embedded systems.
+
 config RTC_DRV_CPCAP
 	depends on MFD_CPCAP
 	tristate "Motorola CPCAP RTC"
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 4ac8f19..5f00c8b 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -186,3 +186,6 @@ obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
 obj-$(CONFIG_RTC_DRV_XGENE)	+= rtc-xgene.o
 obj-$(CONFIG_RTC_DRV_ZYNQMP)	+= rtc-zynqmp.o
+obj-$(CONFIG_RTC_DRV_NUA3500)	+= rtc-nua3500.o
+
+
diff --git a/drivers/rtc/rtc-nua3500.c b/drivers/rtc/rtc-nua3500.c
new file mode 100644
index 0000000..6fb5130
--- /dev/null
+++ b/drivers/rtc/rtc-nua3500.c
@@ -0,0 +1,417 @@
+/*
+ * Copyright (c) 2020 Nuvoton technology corporation.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/rtc.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/bcd.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+
+
+/* RTC Control Registers */
+#define REG_RTC_INIR    0x00
+#define REG_RTC_AER	    0x04
+#define REG_RTC_FCR	    0x08
+#define REG_RTC_TLR	    0x0C
+#define REG_RTC_CLR	    0x10
+#define REG_RTC_TSSR    0x14
+#define REG_RTC_DWR	    0x18
+#define REG_RTC_TAR	    0x1C
+#define REG_RTC_CAR	    0x20
+#define REG_RTC_LIR	    0x24
+#define REG_RTC_RIER    0x28
+#define REG_RTC_RIIR    0x2C
+#define REG_RTC_TTR	    0x30
+#define REG_RTC_PWRCTL  0x34
+
+
+#define RTCSET          0x01
+#define AERRWENB        0x10000
+#define INIRRESET       0xa5eb1357
+#define AERPOWERON      0xA965
+#define AERPOWEROFF     0x0000
+#define LEAPYEAR        0x0001
+#define TICKENB         0x80
+#define TICKINTENB      0x0002
+#define ALARMINTENB     0x0001
+#define MODE24          0x0001
+
+struct clk *rtc_clk;
+
+struct nua3500_rtc {
+	int irq_num;
+	void __iomem *rtc_reg;
+	struct rtc_device *rtcdev;
+};
+
+struct nua3500_bcd_time {
+	int bcd_sec;
+	int bcd_min;
+	int bcd_hour;
+	int bcd_mday;
+	int bcd_mon;
+	int bcd_year;
+};
+
+static inline unsigned int rtc_reg_read(struct nua3500_rtc *p, int offset)
+{
+	return(__raw_readl(p->rtc_reg + offset));
+}
+
+static inline void rtc_reg_write(struct nua3500_rtc *p, int offset, int value)
+{
+	unsigned int writetimeout = 0x400;
+
+	__raw_writel(value, p->rtc_reg + offset);
+
+	// wait rtc register write finish
+	while((__raw_readl(p->rtc_reg + REG_RTC_RIIR) & (1 << 31)) && writetimeout--)
+		udelay(1);
+}
+
+static irqreturn_t nua3500_rtc_interrupt(int irq, void *_rtc)
+{
+	struct nua3500_rtc *rtc = _rtc;
+	unsigned long events = 0, rtc_irq;
+
+	rtc_irq = __raw_readl(rtc->rtc_reg + REG_RTC_RIIR);
+
+	if (rtc_irq & ALARMINTENB) {
+		rtc_reg_write(rtc, REG_RTC_RIIR, ALARMINTENB);
+		events |= RTC_AF | RTC_IRQF;
+	}
+
+	if (rtc_irq & TICKINTENB) {
+		rtc_reg_write(rtc, REG_RTC_RIIR, TICKINTENB);
+		events |= RTC_UF | RTC_IRQF;
+	}
+
+	rtc_update_irq(rtc->rtcdev, 1, events);
+
+	return IRQ_HANDLED;
+}
+
+static int *check_rtc_access_enable(struct nua3500_rtc *nua3500_rtc)
+{
+	rtc_reg_write(nua3500_rtc, REG_RTC_INIR, INIRRESET);
+
+	mdelay(1);
+
+	rtc_reg_write(nua3500_rtc, REG_RTC_AER, AERPOWERON);
+
+	mdelay(1);
+
+	return 0;
+}
+
+static int nua3500_rtc_bcd2bin(unsigned int timereg,
+				unsigned int calreg, unsigned int wdayreg, struct rtc_time *tm)
+{
+	tm->tm_mday	= bcd2bin(calreg >> 0);
+	tm->tm_mon	= bcd2bin(calreg >> 8);
+	tm->tm_mon	= tm->tm_mon - 1;
+
+	tm->tm_year	= bcd2bin(calreg >> 16) + 100;
+
+	tm->tm_sec	= bcd2bin(timereg >> 0);
+	tm->tm_min	= bcd2bin(timereg >> 8);
+	tm->tm_hour	= bcd2bin(timereg >> 16);
+
+	tm->tm_wday = wdayreg;
+
+	return rtc_valid_tm(tm);
+}
+
+static int nua3500_rtc_alarm_bcd2bin(unsigned int timereg,
+				unsigned int calreg, struct rtc_time *tm)
+{
+	tm->tm_mday	= bcd2bin(calreg >> 0);
+	tm->tm_mon	= bcd2bin(calreg >> 8);
+	tm->tm_mon	= tm->tm_mon - 1;
+
+	tm->tm_year	= bcd2bin(calreg >> 16) + 100;
+
+	tm->tm_sec	= bcd2bin(timereg >> 0);
+	tm->tm_min	= bcd2bin(timereg >> 8);
+	tm->tm_hour	= bcd2bin(timereg >> 16);
+
+	return rtc_valid_tm(tm);
+}
+
+static void nua3500_rtc_bin2bcd(struct device *dev, struct rtc_time *settm,
+						struct nua3500_bcd_time *gettm)
+{
+	gettm->bcd_mday = bin2bcd(settm->tm_mday) << 0;
+	gettm->bcd_mon  = bin2bcd((settm->tm_mon + 1)) << 8;
+
+	if (settm->tm_year < 100) {
+		dev_warn(dev, "The year will be between 1970-1999, right?\n");
+		gettm->bcd_year = bin2bcd(settm->tm_year) << 16;
+	} else {
+		gettm->bcd_year = bin2bcd(settm->tm_year - 100) << 16;
+	}
+
+	gettm->bcd_sec  = bin2bcd(settm->tm_sec) << 0;
+	gettm->bcd_min  = bin2bcd(settm->tm_min) << 8;
+	gettm->bcd_hour = bin2bcd(settm->tm_hour) << 16;
+}
+
+static int nua3500_alarm_irq_enable(struct device *dev, unsigned int enabled)
+{
+	struct nua3500_rtc *rtc = dev_get_drvdata(dev);
+
+	if (enabled)
+		rtc_reg_write(rtc, REG_RTC_RIER, (__raw_readl(rtc->rtc_reg + REG_RTC_RIER)|(ALARMINTENB)));
+	else
+		rtc_reg_write(rtc, REG_RTC_RIER, (__raw_readl(rtc->rtc_reg + REG_RTC_RIER)&(~ALARMINTENB)));
+	return 0;
+}
+
+static int nua3500_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct nua3500_rtc *rtc = dev_get_drvdata(dev);
+	unsigned int timeval, clrval, wdayval;
+
+	timeval = __raw_readl(rtc->rtc_reg + REG_RTC_TLR);
+	clrval  = __raw_readl(rtc->rtc_reg + REG_RTC_CLR);
+	wdayval = __raw_readl(rtc->rtc_reg + REG_RTC_DWR);
+
+	return nua3500_rtc_bcd2bin(timeval, clrval, wdayval, tm);
+}
+
+static int nua3500_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct nua3500_rtc *rtc = dev_get_drvdata(dev);
+	struct nua3500_bcd_time gettm;
+	unsigned long val;
+	int *err;
+
+	nua3500_rtc_bin2bcd(dev, tm, &gettm);
+
+	err = check_rtc_access_enable(rtc);
+	if (IS_ERR(err))
+		return PTR_ERR(err);
+
+	val = gettm.bcd_mday | gettm.bcd_mon | gettm.bcd_year;
+	rtc_reg_write(rtc, REG_RTC_CLR, val);
+
+	val = gettm.bcd_sec | gettm.bcd_min | gettm.bcd_hour;
+	rtc_reg_write(rtc, REG_RTC_TLR, val);
+
+	val = tm->tm_wday;
+	rtc_reg_write(rtc, REG_RTC_DWR, val);
+
+	return 0;
+}
+
+static int nua3500_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct nua3500_rtc *rtc = dev_get_drvdata(dev);
+	unsigned int timeval, carval;
+
+	timeval = __raw_readl(rtc->rtc_reg + REG_RTC_TAR);
+	carval  = __raw_readl(rtc->rtc_reg + REG_RTC_CAR);
+
+	return nua3500_rtc_alarm_bcd2bin(timeval, carval, &alrm->time);
+}
+
+static int nua3500_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct nua3500_rtc *rtc = dev_get_drvdata(dev);
+	struct nua3500_bcd_time tm;
+	unsigned long val;
+	int *err;
+
+	nua3500_rtc_bin2bcd(dev, &alrm->time, &tm);
+
+	err = check_rtc_access_enable(rtc);
+	if (IS_ERR(err))
+		return PTR_ERR(err);
+
+	val = tm.bcd_mday | tm.bcd_mon | tm.bcd_year;
+	val |= (1 << 31); // mask alarm week day
+	rtc_reg_write(rtc, REG_RTC_CAR, val);
+
+	val = tm.bcd_sec | tm.bcd_min | tm.bcd_hour;
+	rtc_reg_write(rtc, REG_RTC_TAR, val);
+
+	rtc_reg_write(rtc, REG_RTC_PWRCTL, (__raw_readl(rtc->rtc_reg + REG_RTC_PWRCTL) | (1 << 3)));
+
+	return 0;
+}
+
+static int nua3500_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
+{
+	struct nua3500_rtc *rtc = dev_get_drvdata(dev);
+	unsigned int spare_data[16], i;
+	int *err;
+
+	switch(cmd)
+	{
+		case RTC_GET_SPARE_DATA:
+			err = check_rtc_access_enable(rtc);
+			if (IS_ERR(err))
+				return PTR_ERR(err);
+
+			for(i = 0; i < 16; i++)
+			{
+				spare_data[i] =  __raw_readl(rtc->rtc_reg + (0x40+(i*4)));
+			}
+
+			if(copy_to_user((void*)arg, (void *)&spare_data[0], sizeof(spare_data)))
+			{
+				return -EFAULT;
+			}
+
+		break;
+
+		case RTC_SET_SPARE_DATA:
+			if(copy_from_user((void *)&spare_data[0], (void*)arg, sizeof(spare_data)))
+			{
+				return -EFAULT;
+			}
+
+			err = check_rtc_access_enable(rtc);
+			if (IS_ERR(err))
+				return PTR_ERR(err);
+
+			for(i = 0; i < 16; i++)
+			{
+				rtc_reg_write(rtc, (0x40+(i*4)), spare_data[i]);
+			}
+
+		break;
+
+		default:
+			return -ENOIOCTLCMD;
+	}
+
+	return 0;
+}
+
+static struct rtc_class_ops nua3500_rtc_ops = {
+	.read_time = nua3500_rtc_read_time,
+	.set_time = nua3500_rtc_set_time,
+	.read_alarm = nua3500_rtc_read_alarm,
+	.set_alarm = nua3500_rtc_set_alarm,
+	.alarm_irq_enable = nua3500_alarm_irq_enable,
+	.ioctl = nua3500_ioctl,
+};
+
+static int nua3500_rtc_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct nua3500_rtc *nua3500_rtc;
+	unsigned char __iomem * sys_base;
+
+	sys_base = ioremap_nocache(0x40460000, 0x10000);
+	__raw_writel(__raw_readl(sys_base+0x200) | (0xf << 0),sys_base+0x200);
+	__raw_writel(__raw_readl(sys_base+0x20C) | (0x1 << 29),sys_base+0x20C);  // Enable RTC clock
+
+	nua3500_rtc = devm_kzalloc(&pdev->dev, sizeof(struct nua3500_rtc), GFP_KERNEL);
+	if (!nua3500_rtc) {
+		dev_err(&pdev->dev, "kzalloc nuc900_rtc failed\n");
+		return -ENOMEM;
+	}
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	nua3500_rtc->rtc_reg = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(nua3500_rtc->rtc_reg))
+		return PTR_ERR(nua3500_rtc->rtc_reg);
+
+	platform_set_drvdata(pdev, nua3500_rtc);
+
+	nua3500_rtc->rtcdev = devm_rtc_device_register(&pdev->dev, pdev->name, &nua3500_rtc_ops, THIS_MODULE);
+	if (IS_ERR(nua3500_rtc->rtcdev)) {
+		dev_err(&pdev->dev, "rtc device register failed\n");
+		return PTR_ERR(nua3500_rtc->rtcdev);
+	}
+
+	rtc_reg_write(nua3500_rtc, REG_RTC_TSSR, (__raw_readl(nua3500_rtc->rtc_reg + REG_RTC_TSSR) | MODE24));
+
+	nua3500_rtc->irq_num = platform_get_irq(pdev, 0);
+
+	if (devm_request_irq(&pdev->dev, nua3500_rtc->irq_num,
+			nua3500_rtc_interrupt, IRQF_NO_SUSPEND, "nua3500rtc", nua3500_rtc)) {
+		dev_err(&pdev->dev, "nua3500 RTC request irq failed\n");
+		return -EBUSY;
+	}
+
+	rtc_reg_write(nua3500_rtc, REG_RTC_RIER, (__raw_readl(nua3500_rtc->rtc_reg + REG_RTC_RIER) | TICKINTENB));
+
+	device_init_wakeup(&pdev->dev, true);
+
+	return 0;
+}
+
+static int __exit nua3500_rtc_remove(struct platform_device *pdev)
+{
+	device_init_wakeup(&pdev->dev, 0);
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static int nua3500_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct nua3500_rtc *nua3500_rtc = platform_get_drvdata(pdev);
+	
+	if (device_may_wakeup(&pdev->dev))
+		enable_irq_wake(nua3500_rtc->irq_num);
+
+	rtc_reg_write(nua3500_rtc, REG_RTC_RIER, (__raw_readl(nua3500_rtc->rtc_reg + REG_RTC_RIER) &~ TICKINTENB));
+
+	return 0;
+}
+
+static int nua3500_rtc_resume(struct platform_device *pdev)
+{
+	struct nua3500_rtc *nua3500_rtc = platform_get_drvdata(pdev);
+
+	if (device_may_wakeup(&pdev->dev))
+		disable_irq_wake(nua3500_rtc->irq_num);
+
+	rtc_reg_write(nua3500_rtc, REG_RTC_RIER, (__raw_readl(nua3500_rtc->rtc_reg + REG_RTC_RIER) | TICKINTENB));
+
+	return 0;
+}
+
+static const struct of_device_id nua3500_rtc_of_match[] = {
+	{ .compatible = "nuvoton,nua3500-rtc"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, nua3500_rtc_of_match);
+
+
+static struct platform_driver nua3500_rtc_driver = {
+	.remove     = __exit_p(nua3500_rtc_remove),
+	.suspend    = nua3500_rtc_suspend,
+	.resume     = nua3500_rtc_resume,
+	.probe      = nua3500_rtc_probe,
+	.driver		= {
+		.name	= "nua3500-rtc",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(nua3500_rtc_of_match),
+	},
+};
+
+module_platform_driver(nua3500_rtc_driver);
+
+MODULE_AUTHOR("nuvoton");
+MODULE_DESCRIPTION("nua3500 RTC driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:nua3500-rtc");
diff --git a/include/uapi/linux/rtc.h b/include/uapi/linux/rtc.h
index 2ad1788..a571453 100644
--- a/include/uapi/linux/rtc.h
+++ b/include/uapi/linux/rtc.h
@@ -95,6 +95,9 @@ struct rtc_pll_info {
 #define RTC_VL_READ	_IOR('p', 0x13, int)	/* Voltage low detector */
 #define RTC_VL_CLR	_IO('p', 0x14)		/* Clear voltage low information */
 
+#define RTC_GET_SPARE_DATA    _IOR('p', 0x20, unsigned long) /* Get spare register data */
+#define RTC_SET_SPARE_DATA    _IOW('p', 0x21, unsigned long) /* Set spare register data */
+
 /* interrupt flags */
 #define RTC_IRQF 0x80	/* Any of the following is active */
 #define RTC_PF 0x40	/* Periodic interrupt */
-- 
2.0.3

