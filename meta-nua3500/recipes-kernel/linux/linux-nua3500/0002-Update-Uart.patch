From db86605ba22ae6805035c4edf7ad8dece890b9d7 Mon Sep 17 00:00:00 2001
From: mjchen <mjchen@nuvoton.com>
Date: Fri, 10 Jul 2020 10:42:28 +0800
Subject: [PATCH 2/7] Update Uart

Change-Id: I3ec8360083ebfaa899845f13d2e2c19e46df7138
---
 drivers/tty/serial/nua3500_serial.c | 1134 ++---------------------------------
 1 file changed, 56 insertions(+), 1078 deletions(-)

diff --git a/drivers/tty/serial/nua3500_serial.c b/drivers/tty/serial/nua3500_serial.c
index 799c00b..f2bd056 100755
--- a/drivers/tty/serial/nua3500_serial.c
+++ b/drivers/tty/serial/nua3500_serial.c
@@ -42,31 +42,9 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/serial.h>
-
-//#include <mach/map.h>
-//#include <mach/regs-serial.h>
-//#include <mach/regs-gcr.h>
-//#include <mach/mfp.h>
-//#include <mach/regs-pdma.h>
-//#include <mach/sram.h>
-//#include <linux/platform_data/dma-nua3500.h>
-
-
 #include "nua3500_serial.h"
 
-u64 uart0_base;
-
-//#define USING_SRAM
-#define UART_NR 1
-#define UART_RX_BUF_SIZE 128 //bytes
-#define UART_TX_MAX_BUF_SIZE 128 //bytes
-
-//#define CONFIG_USE_DDR 1
-
-// PDMA mode time-out
-#define Time_Out_Frame_Count 2
-#define Time_Out_Low_Baudrate 9600
-
+#define UART_NR 16
 
 static struct uart_driver nua3500serial_reg;
 
@@ -84,28 +62,7 @@ struct uart_nua3500_port {
 
 	struct serial_rs485 rs485; /* rs485 settings */
 
-#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-	struct nua3500_ip_rx_dma dma_rx;
-	struct nua3500_ip_tx_dma dma_tx;
-	struct nua3500_mem_alloc src_mem_p;
-	struct nua3500_mem_alloc dest_mem_p;
-	struct nua3500_dma_done   dma_slave_done;
-
-	unsigned char PDMA_UARTx_TX;
-	unsigned char PDMA_UARTx_RX;
-
-	struct nua3500_dma_done   dma_Rx_done;
-	struct nua3500_dma_done   dma_Tx_done;
-
-	unsigned int tx_dma_len;
-
 	unsigned char uart_pdma_enable_flag;
-	unsigned char Tx_pdma_busy_flag;
-
-	unsigned int pdma_time_out_prescaler;
-	unsigned int pdma_time_out_count;
-	unsigned int baud_rate;
-#endif
 
 	/*
 	* We provide a per-port pm hook.
@@ -118,11 +75,6 @@ static struct uart_nua3500_port nua3500serial_ports[UART_NR]={0};
 
 static inline void __stop_tx(struct uart_nua3500_port *p);
 
-#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-static void nua3500_prepare_RX_dma(struct uart_nua3500_port *p);
-static void nua3500_prepare_TX_dma(struct uart_nua3500_port *p);
-#endif
-
 static inline struct uart_nua3500_port *
 to_nua3500_uart_port(struct uart_port *uart)
 {
@@ -139,366 +91,20 @@ static inline void serial_out(struct uart_nua3500_port *p, int offset, int value
 	__raw_writel(value, p->port.membase + offset);
 }
 
-#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-
-static void nua3500_Rx_dma_callback(void *arg)
-{
-	struct nua3500_dma_done *done = arg;
-	struct uart_nua3500_port *p = (struct uart_nua3500_port *)done->callback_param;
-	struct tty_port    *tty_port = &p->port.state->port;
-	int count;
-	int copied_count = 0;
-
-	if(done->timeout==1)
-		count = ((p->dest_mem_p.size/2) -(done->remain +1));
-	else
-		count = (p->dest_mem_p.size/2);
-
-	spin_lock(&p->port.lock);
-
-	if(done->base_addr==1)
-		copied_count = tty_insert_flip_string(tty_port, (unsigned char *)(p->dest_mem_p.vir_addr), count);
-	else
-		copied_count = tty_insert_flip_string(tty_port, (unsigned char *)(p->dest_mem_p.vir_addr+(p->dest_mem_p.size/2)), count);
-
-	if(copied_count != count) {
-		printk("\n Rx overrun: dropping %u bytes \n", (count - copied_count));
-	}
-
-	p->port.icount.rx +=copied_count;
-
-	tty_flip_buffer_push(tty_port);
-
-	spin_unlock(&p->port.lock);
-
-	if(done->timeout==1) {
-		nua3500_prepare_RX_dma(p);
-		//Trigger Rx dma again
-		serial_out(p, UART_REG_IER, (serial_in(p, UART_REG_IER)|RXPDMAEN));
-	}
-
-	return;
-}
-
-static void nua3500_Tx_dma_callback(void *arg)
-{
-	struct nua3500_dma_done *done = arg;
-	struct uart_nua3500_port *p = (struct uart_nua3500_port *)done->callback_param;
-	struct circ_buf *xmit = &p->port.state->xmit;
-
-	spin_lock(&p->port.lock);
-
-	p->port.icount.tx += p->tx_dma_len;
-
-	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
-		uart_write_wakeup(&p->port);
-
-	if (!uart_circ_empty(xmit) && !uart_tx_stopped(&p->port)) {
-		p->Tx_pdma_busy_flag = 1;
-		nua3500_prepare_TX_dma(p);
-		// Trigger Tx dma again
-		serial_out(p, UART_REG_IER, (serial_in(p, UART_REG_IER)| TXPDMAEN));
-	} else {
-		p->Tx_pdma_busy_flag = 0;
-	}
-
-	spin_unlock(&p->port.lock);
-}
-
 static void set_pdma_flag(struct uart_nua3500_port *p, int id)
 {
-#if defined(CONFIG_ENABLE_UART1_PDMA) || defined(CONFIG_OF)
 	if(id == 1) {
 		p->uart_pdma_enable_flag = 1;
-		p->PDMA_UARTx_RX = PDMA_UART1_RX;
-		p->PDMA_UARTx_TX = PDMA_UART1_TX;
 	}
-#endif
-
-#if defined(CONFIG_ENABLE_UART2_PDMA) || defined(CONFIG_OF)
-	if(id == 2) {
-		p->uart_pdma_enable_flag = 1;
-		p->PDMA_UARTx_RX = PDMA_UART2_RX;
-		p->PDMA_UARTx_TX = PDMA_UART2_TX;
-	}
-#endif
-
-#if defined(CONFIG_ENABLE_UART3_PDMA) || defined(CONFIG_OF)
-	if(id == 3) {
-		p->uart_pdma_enable_flag = 1;
-		p->PDMA_UARTx_RX = PDMA_UART3_RX;
-		p->PDMA_UARTx_TX = PDMA_UART3_TX;
-	}
-#endif
-
-#if defined(CONFIG_ENABLE_UART4_PDMA) || defined(CONFIG_OF)
-	if(id == 4) {
-		p->uart_pdma_enable_flag = 1;
-		p->PDMA_UARTx_RX = PDMA_UART4_RX;
-		p->PDMA_UARTx_TX = PDMA_UART4_TX;
-	}
-#endif
-
-#if defined(CONFIG_ENABLE_UART5_PDMA) || defined(CONFIG_OF)
-	if(id == 5) {
-		p->uart_pdma_enable_flag = 1;
-		p->PDMA_UARTx_RX = PDMA_UART5_RX;
-		p->PDMA_UARTx_TX = PDMA_UART5_TX;
-	}
-#endif
-
-#if defined(CONFIG_ENABLE_UART6_PDMA) || defined(CONFIG_OF)
-	if(id == 6) {
-		p->uart_pdma_enable_flag = 1;
-		p->PDMA_UARTx_RX = PDMA_UART6_RX;
-		p->PDMA_UARTx_TX = PDMA_UART6_TX;
-	}
-#endif
-
-#if defined(CONFIG_ENABLE_UART7_PDMA) || defined(CONFIG_OF)
-	if(id == 7) {
-		p->uart_pdma_enable_flag = 1;
-		p->PDMA_UARTx_RX = PDMA_UART7_RX;
-		p->PDMA_UARTx_TX = PDMA_UART7_TX;
-	}
-#endif
-
-#if defined(CONFIG_ENABLE_UART8_PDMA) || defined(CONFIG_OF)
-	if(id == 8) {
-		p->uart_pdma_enable_flag = 1;
-		p->PDMA_UARTx_RX = PDMA_UART8_RX;
-		p->PDMA_UARTx_TX = PDMA_UART8_TX;
-	}
-#endif
-
-#if defined(CONFIG_ENABLE_UART9_PDMA) || defined(CONFIG_OF)
-	if(id == 9) {
-		p->uart_pdma_enable_flag = 1;
-		p->PDMA_UARTx_RX = PDMA_UART9_RX;
-		p->PDMA_UARTx_TX = PDMA_UART9_TX;
-	}
-#endif
 }
 
-#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-void nua3500_uart_cal_pdma_time_out(struct uart_nua3500_port *p, unsigned int baud)
-{
-	unsigned int lcr;
-	unsigned int pdma_time_out_base = 300000000 * Time_Out_Frame_Count / 256; // 300M*Time_Out_Frame_Count/256
-	unsigned int time_out_prescaler = 0;
-	unsigned int bit_length;
-	unsigned int time_out;
-
-	if(baud > Time_Out_Low_Baudrate){
-		p->pdma_time_out_count = 255;
-		p->pdma_time_out_prescaler = 7;
-
-		return;
-	}
-
-	bit_length = 2;//1 start + 1 stop bit
-
-	lcr = serial_in(p, UART_REG_LCR);
-	switch(lcr & 0x3){
-		case 0:
-			bit_length += 5;
-
-			break;
-		case 1:
-			bit_length += 6;
-
-			break;
-		case 2:
-			bit_length += 7;
-
-			break;
-		case 3:
-			bit_length += 8;
-
-			break;
-	}
-
-	if(lcr & 0x4)
-		bit_length += 1;
-
-	if(lcr & 0x8)//Parity bit
-		bit_length += 1;
-
-	time_out = pdma_time_out_base * bit_length;
-	time_out = (time_out / baud) + 1;
-
-	while(time_out > 65535) // pdma max. time-out count is 65535
-	{
-		time_out = time_out / 2;
-		time_out_prescaler++;
-	}
-
-	if(time_out == 0) time_out = 1;
-
-	p->pdma_time_out_count = time_out;
-	p->pdma_time_out_prescaler = time_out_prescaler;
-
-	return;
-}
-#endif
-
-static void nua3500_prepare_RX_dma(struct uart_nua3500_port *p)
-{
-	struct nua3500_dma_config dma_crx;
-	struct nua3500_ip_rx_dma *pdma_rx = &(p->dma_rx);
-	dma_cookie_t cookie;
-
-	serial_out(p, UART_REG_IER, (serial_in(p, UART_REG_IER)&~ RXPDMAEN));
-
-	if(p->dest_mem_p.size == 0) {
-		// use DDR
-#ifndef USING_SRAM
-		//p->dest_mem_p.size = 256;
-		p->dest_mem_p.size = 4096*2;
-		p->dest_mem_p.vir_addr = (u64)dma_alloc_writecombine(NULL,
-		                         PAGE_ALIGN(p->dest_mem_p.size),
-		                         (dma_addr_t *)&(p->dest_mem_p.phy_addr),
-		                         GFP_KERNEL);
-#else
-		p->dest_mem_p.size = 256; //set to 256 bytes
-		p->dest_mem_p.vir_addr =(u32)sram_alloc(p->dest_mem_p.size, &(p->dest_mem_p.phy_addr));
-#endif
-	}
-
-	pdma_rx->slave_config.src_addr = (u64)(p->port.membase - 0x40000000);
-	pdma_rx->slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
-	pdma_rx->slave_config.src_maxburst = 1;
-	pdma_rx->slave_config.direction = DMA_DEV_TO_MEM;
-	pdma_rx->slave_config.device_fc = false;
-	dmaengine_slave_config(pdma_rx->chan_rx,&(pdma_rx->slave_config));
-
-	sg_init_table(pdma_rx->sgrx, 1);
-	pdma_rx->sgrx[0].dma_address = p->dest_mem_p.phy_addr;
-	pdma_rx->sgrx[0].length = p->dest_mem_p.size;
-	dma_crx.reqsel = p->PDMA_UARTx_RX;
-
-	dma_crx.timeout_counter = p->pdma_time_out_count;
-	dma_crx.timeout_prescaler = p->pdma_time_out_prescaler;
-
-	dma_crx.en_sc = 1;
-	pdma_rx->rxdesc=pdma_rx->chan_rx->device->device_prep_slave_sg(pdma_rx->chan_rx,
-	                pdma_rx->sgrx,
-	                1,
-	                DMA_FROM_DEVICE,
-	                DMA_PREP_INTERRUPT | DMA_CTRL_ACK,
-	                (void *)&dma_crx); //PDMA Request Source Select
-	if (!pdma_rx->rxdesc) {
-		printk("pdma->rxdesc=NULL\n");
-		while(1);
-	}
-	//dma_slave_done.done = false;
-	pdma_rx->rxdesc->callback = nua3500_Rx_dma_callback;
-	p->dma_Rx_done.callback_param = p;
-	p->dma_Rx_done.base_addr = 0;
-	p->dma_Rx_done.timeout = 0;
-	pdma_rx->rxdesc->callback_param = &(p->dma_Rx_done);
-	cookie = pdma_rx->rxdesc->tx_submit(pdma_rx->rxdesc);
-	if (dma_submit_error(cookie)) {
-		printk("rx dma_submit_error  \n");
-		while(1);
-	}
-
-}
-
-static void nua3500_prepare_TX_dma(struct uart_nua3500_port *p)
-{
-	struct nua3500_dma_config dma_ctx;
-	struct nua3500_ip_tx_dma *pdma_tx = &(p->dma_tx);
-	dma_cookie_t cookie;
-	struct circ_buf *xmit = &p->port.state->xmit;
-
-	if(p->src_mem_p.size == 0) {
-		p->src_mem_p.size = UART_XMIT_SIZE;
-		p->src_mem_p.vir_addr = (u64)dma_alloc_writecombine(NULL,
-		                        PAGE_ALIGN(p->src_mem_p.size),
-		                        (dma_addr_t *)&(p->src_mem_p.phy_addr),
-		                        GFP_KERNEL);
-	}
-
-	p->tx_dma_len = uart_circ_chars_pending(xmit);
-	if (xmit->tail < xmit->head) {
-		memcpy((unsigned char *)p->src_mem_p.vir_addr, &xmit->buf[xmit->tail], p->tx_dma_len);
-	} else {
-		size_t first = UART_XMIT_SIZE - xmit->tail;
-		size_t second = xmit->head;
-		memcpy((unsigned char *)p->src_mem_p.vir_addr, &xmit->buf[xmit->tail], first);
-		if (second)
-			memcpy((unsigned char *)p->src_mem_p.vir_addr+first, &xmit->buf[0], second);
-	}
-	xmit->tail = (xmit->tail +  p->tx_dma_len) & (UART_XMIT_SIZE - 1);
-
-	serial_out(p, UART_REG_IER, (serial_in(p, UART_REG_IER) &~ TXPDMAEN));
-	pdma_tx->slave_config.dst_addr = (u64)(p->port.membase - 0x40000000);
-	pdma_tx->slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
-	pdma_tx->slave_config.dst_maxburst = 1;
-	pdma_tx->slave_config.direction = DMA_MEM_TO_DEV;
-	dmaengine_slave_config(pdma_tx->chan_tx,&(pdma_tx->slave_config));
-	sg_init_table(pdma_tx->sgtx, 1);
-	pdma_tx->sgtx[0].dma_address =p->src_mem_p.phy_addr;
-	pdma_tx->sgtx[0].length = p->tx_dma_len;
-	dma_ctx.reqsel = p->PDMA_UARTx_TX;
-	// disable time-out
-	dma_ctx.timeout_counter = 0;
-	dma_ctx.timeout_prescaler = 0;
-	dma_ctx.en_sc = 0;
-	pdma_tx->txdesc = pdma_tx->chan_tx->device->device_prep_slave_sg(pdma_tx->chan_tx,
-	                  pdma_tx->sgtx,
-	                  1,
-	                  DMA_TO_DEVICE,
-	                  DMA_PREP_INTERRUPT | DMA_CTRL_ACK,
-	                  (void *)&dma_ctx);
-	if (!pdma_tx->txdesc) {
-		printk("pdma->txdes==NULL\n");
-		while(1);
-	}
-
-	pdma_tx->txdesc->callback = nua3500_Tx_dma_callback;
-	p->dma_Tx_done.callback_param = p;
-	pdma_tx->txdesc->callback_param = &(p->dma_Tx_done);
-
-	cookie = pdma_tx->txdesc->tx_submit(pdma_tx->txdesc);
-	if (dma_submit_error(cookie)) {
-		printk("dma_submit_error\n");
-		while(1);
-	}
-}
-
-#endif
-
-
 static void rs485_start_rx(struct uart_nua3500_port *port)
 {
-#if 0  // user can enable to control RTS pin level
-	// when enable this define, user need disable auto-flow control
-	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
 
-	if(port->rs485.flags & SER_RS485_RTS_AFTER_SEND) {
-		// Set logical level for RTS pin equal to high
-		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) & ~0x200) );
-	} else {
-		// Set logical level for RTS pin equal to low
-		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) | 0x200) );
-	}
-#endif
 }
 
 static void rs485_stop_rx(struct uart_nua3500_port *port)
 {
-#if 0  // user can enable to control RTS pin level
-	// when enable this define, user need disable auto-flow control
-	if(port->rs485.flags & SER_RS485_RTS_ON_SEND) {
-		// Set logical level for RTS pin equal to high
-		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) & ~0x200) );
-	} else {
-		// Set logical level for RTS pin equal to low
-		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) | 0x200) );
-	}
-#endif
 
 }
 
@@ -519,7 +125,6 @@ static inline void __stop_tx(struct uart_nua3500_port *p)
 
 		serial_out(p, UART_REG_IRCR, (serial_in(p, UART_REG_IRCR) & ~0x2) ); // Tx disable (select Rx)
 	}
-
 }
 
 static void nua3500serial_stop_tx(struct uart_port *port)
@@ -536,9 +141,7 @@ static void nua3500serial_start_tx(struct uart_port *port)
 	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
 	unsigned int ier;
 	struct tty_struct *tty = up->port.state->port.tty;
-#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
 	struct circ_buf *xmit = &up->port.state->xmit;
-#endif
 
 	if (tty->termios.c_line == N_IRDA) {
 		serial_out(up, UART_REG_IRCR, (serial_in(up, UART_REG_IRCR) | 0x2) ); // Tx enable
@@ -547,38 +150,11 @@ static void nua3500serial_start_tx(struct uart_port *port)
 	if (up->rs485.flags & SER_RS485_ENABLED)
 		rs485_stop_rx(up);
 
-#if 0   // No use FIFO
-	if (!((ier = serial_in(up, UART_REG_IER)) & THRE_IEN)) {
-		ier |= THRE_IEN;
-		serial_out(up, UART_REG_IER, ier);
-	}
-#else // use FIFO
-#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-	if(up->uart_pdma_enable_flag == 1) {
-		if(up->Tx_pdma_busy_flag == 1) {
-			return;
-		}
-
-		if (uart_circ_empty(xmit)) {
-			__stop_tx(up);
-			return;
-		}
-
-		up->Tx_pdma_busy_flag = 1;
-		nua3500_prepare_TX_dma(up);
-		serial_out(up, UART_REG_IER, (serial_in(up, UART_REG_IER)|TXPDMAEN));
-	} else
-#endif
-	{
-		struct circ_buf *xmit = &up->port.state->xmit;
-		ier = serial_in(up, UART_REG_IER);
-		serial_out(up, UART_REG_IER, ier & ~THRE_IEN);
-		if( uart_circ_chars_pending(xmit)<(16-((serial_in(up, UART_REG_FSR)>>16)&0x3F)) )
-			transmit_chars(up);
-		serial_out(up, UART_REG_IER, ier | THRE_IEN);
-	}
-#endif
-
+	ier = serial_in(up, UART_REG_IER);
+	serial_out(up, UART_REG_IER, ier & ~THRE_IEN);
+	if( uart_circ_chars_pending(xmit)<(16-((serial_in(up, UART_REG_FSR)>>16)&0x3F)) )
+		transmit_chars(up);
+	serial_out(up, UART_REG_IER, ier | THRE_IEN);
 }
 
 static void nua3500serial_stop_rx(struct uart_port *port)
@@ -679,7 +255,6 @@ receive_chars(struct uart_nua3500_port *up)
 static void transmit_chars(struct uart_nua3500_port *up)
 {
 	struct circ_buf *xmit = &up->port.state->xmit;
-	//int count = 12;
 	int count = 16 -((serial_in(up, UART_REG_FSR)>>16)&0xF);
 
 	if(serial_in(up, UART_REG_FSR) & TX_FULL){
@@ -705,7 +280,7 @@ static void transmit_chars(struct uart_nua3500_port *up)
 	}
 
 	while(count > 0){
-		//while(serial_in(up, UART_REG_FSR) & TX_FULL);
+		while(serial_in(up, UART_REG_FSR) & TX_FULL);
 		serial_out(up, UART_REG_THR, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		up->port.icount.tx++;
@@ -740,19 +315,13 @@ static irqreturn_t nua3500serial_interrupt(int irq, void *dev_id)
 
 	isr = serial_in(up, UART_REG_ISR);
 	fsr = serial_in(up, UART_REG_FSR);
-//	printk("nua3500serial_interrupt isr=0x%08x, fsr=0x%08x\n",isr,fsr);
-#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+
 	if(up->uart_pdma_enable_flag == 1) {
 		if(fsr & (BIF | FEF | PEF | RX_OVER_IF | HWBUFE_IF | TX_OVER_IF)) {
 			serial_out(up, UART_REG_FSR, (BIF | FEF | PEF | RX_OVER_IF | TX_OVER_IF));
 		}
-	} else
-#endif
-	{
-		//isr = serial_in(up, UART_REG_ISR);
-
+	} else {
 		if (isr & (RDA_IF | TOUT_IF)){
-//			printk("receive_chars\n");
 			receive_chars(up);
 		}
 
@@ -772,12 +341,9 @@ static irqreturn_t nua3500serial_interrupt(int irq, void *dev_id)
 static unsigned int nua3500serial_tx_empty(struct uart_port *port)
 {
 	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
-	//unsigned long flags;
 	unsigned int fsr;
 
-	//spin_lock_irqsave(&up->port.lock, flags);
 	fsr = serial_in(up, UART_REG_FSR);
-	//spin_unlock_irqrestore(&up->port.lock, flags);
 
 	return (fsr & (TE_FLAG | TX_EMPTY)) == (TE_FLAG | TX_EMPTY) ? TIOCSER_TEMT : 0;
 }
@@ -857,34 +423,6 @@ static int nua3500serial_startup(struct uart_port *port)
 	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
 	struct tty_struct *tty = port->state->port.tty;
 	int retval;
-//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-//	struct nua3500_ip_rx_dma *pdma_rx = &(up->dma_rx);
-//	struct nua3500_ip_tx_dma *pdma_tx = &(up->dma_tx);
-
-//	dma_cap_mask_t mask;
-//#endif
-
-//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-//	dma_cap_zero(mask);
-//	dma_cap_set(DMA_SLAVE, mask);
-//	dma_cap_set(DMA_PRIVATE, mask);
-
-//	if(up->uart_pdma_enable_flag == 1) {
-//		pdma_rx->chan_rx = dma_request_channel(mask, NULL, NULL);
-//		if (!pdma_rx->chan_rx) {
-//			printk("RX DMA channel request error\n");
-//			return -1;
-//		}
-//		pdma_rx->chan_rx->private=(void *)1;
-
-//		pdma_tx->chan_tx = dma_request_channel(mask, NULL, NULL);
-//		if (!pdma_tx->chan_tx) {
-//			printk("TX DMA channel request error\n");
-//			return -1;
-//		}
-//		pdma_tx->chan_tx->private=(void *)1;
-//	}
-//#endif
 
 	/* Reset FIFO */
 	serial_out(up, UART_REG_FCR, TFR | RFR /* | RX_DIS */);
@@ -903,34 +441,19 @@ static int nua3500serial_startup(struct uart_port *port)
 	 * Now, initialize the UART
 	 */
 
-//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-//	serial_out(up, UART_REG_FCR, serial_in(up, UART_REG_FCR) | 0x0); // Trigger level 1 byte
-//#else
-//	serial_out(up, UART_REG_FCR, serial_in(up, UART_REG_FCR) | 0x10); // Trigger level 4 byte
-//#endif
+	serial_out(up, UART_REG_FCR, serial_in(up, UART_REG_FCR) | 0x10); // Trigger level 4 byte
 
-//	serial_out(up, UART_REG_LCR, 0x7); // 8 bit
-//	serial_out(up, UART_REG_TOR, 0x40);
-
-//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-//	if(up->uart_pdma_enable_flag == 1)
-//		serial_out(up, UART_REG_IER, RLS_IEN | BUFERR_IEN);
-//	else
-//#endif
-	serial_out(up, UART_REG_IER, RTO_IEN | RDA_IEN | TIME_OUT_EN | BUFERR_IEN);
-//	serial_out(up, UART_REG_IER, RTO_IEN | RDA_IEN | TIME_OUT_EN);
-
-	//serial_out(up, UART_REG_IER, RTO_IEN | RDA_IEN | TIME_OUT_EN | THRE_IEN);
+	serial_out(up, UART_REG_LCR, 0x7); // 8 bit
+	serial_out(up, UART_REG_TOR, 0x40);
 
+	if(up->uart_pdma_enable_flag == 1)
+		serial_out(up, UART_REG_IER, RLS_IEN | BUFERR_IEN);
+	else
+		serial_out(up, UART_REG_IER, RTO_IEN | RDA_IEN | TIME_OUT_EN | BUFERR_IEN);
 
-	/* 12MHz reference clock input, 115200 */
-	//serial_out(up, UART_REG_BAUD, 0x30000066);
+	if(up->uart_pdma_enable_flag == 1) {
 
-//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-//	if(up->uart_pdma_enable_flag == 1) {
-//		up->baud_rate = 0;
-//	}
-//#endif
+	}
 
 	return 0;
 }
@@ -938,35 +461,10 @@ static int nua3500serial_startup(struct uart_port *port)
 static void nua3500serial_shutdown(struct uart_port *port)
 {
 	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
-#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-	struct nua3500_ip_rx_dma *pdma_rx = &(up->dma_rx);
-	struct nua3500_ip_tx_dma *pdma_tx = &(up->dma_tx);
-#endif
 
-#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
 	if(up->uart_pdma_enable_flag == 1) {
-		dma_release_channel(pdma_rx->chan_rx);
-		dma_release_channel(pdma_tx->chan_tx);
-
-#ifdef USING_SRAM
-		sram_free((void *)up->dest_mem_p.vir_addr, up->dest_mem_p.size);
-#else
-		if(up->dest_mem_p.size != 0)
-		{
-			dma_free_writecombine(NULL, up->dest_mem_p.size, (void *)up->dest_mem_p.vir_addr, up->dest_mem_p.phy_addr);
-		}
-#endif
-
-		if(up->src_mem_p.size != 0)
-		{
-			dma_free_writecombine(NULL, up->src_mem_p.size, (void *)up->src_mem_p.vir_addr, up->src_mem_p.phy_addr);
-		}
 
-		up->Tx_pdma_busy_flag = 0;
-		up->dest_mem_p.size = 0;
-		up->src_mem_p.size = 0;
 	}
-#endif
 
 	free_irq(port->irq, port);
 
@@ -1058,28 +556,16 @@ nua3500serial_set_termios(struct uart_port *port, struct ktermios *termios, stru
 	nua3500serial_set_mctrl(&up->port, up->port.mctrl);
 
 	//serial_out(up, UART_REG_BAUD, quot | 0x30000000);
-		serial_out(up, UART_REG_BAUD,  0x3000000E); //schung
+	serial_out(up, UART_REG_BAUD,  0x3000000E); // for emulator set baud-rate is 9600
 
 	serial_out(up, UART_REG_LCR, lcr);
 
 	spin_unlock_irqrestore(&up->port.lock, flags);
 
-#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
 	if(up->uart_pdma_enable_flag == 1) {
-		if(up->baud_rate != baud){
-			up->baud_rate = baud;
-
-			nua3500_uart_cal_pdma_time_out(up, baud);
-
-			nua3500_prepare_RX_dma(up);
-
-			nua3500_prepare_TX_dma(up);
-
 			// trigger pdma
-			serial_out(up, UART_REG_IER, (serial_in(up, UART_REG_IER)|RXPDMAEN));
-		}
+			//serial_out(up, UART_REG_IER, (serial_in(up, UART_REG_IER)|RXPDMAEN));
 	}
-#endif
 }
 
 static void
@@ -1090,7 +576,6 @@ nua3500serial_set_ldisc(struct uart_port *port, struct ktermios *termios)
 
 	switch (termios->c_line) {
 	case N_IRDA:
-		#if 0
 		baud = serial_in(uart, UART_REG_BAUD);
 		baud = baud & (0x0000ffff);
 		baud = baud + 2;
@@ -1102,10 +587,6 @@ nua3500serial_set_ldisc(struct uart_port *port, struct ktermios *termios)
 
 		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) & ~FUN_SEL_Msk) );
 		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) | FUN_SEL_IrDA) );
-		#else
-		serial_out(uart, UART_REG_BAUD, 0x3000000E);
-
-		#endif
 		break;
 	default:
 		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) & ~FUN_SEL_Msk) );
@@ -1124,13 +605,8 @@ nua3500serial_pm(struct uart_port *port, unsigned int state, unsigned int oldsta
 
 static void nua3500serial_release_port(struct uart_port *port)
 {
-	//struct platform_device *pdev = to_platform_device(port->dev);
-	//int size = pdev->resource[0].end - pdev->resource[0].start + 1;
-
-	//release_mem_region(port->mapbase, size);
-
-	//iounmap(port->membase);
-	//port->membase = NULL;
+	iounmap(port->membase);
+	port->membase = NULL;
 }
 
 static int nua3500serial_request_port(struct uart_port *port)
@@ -1233,15 +709,12 @@ static void __init nua3500serial_init_ports(void)
 	unsigned char __iomem * sys_base;
 	/* Enable UART0 clock */
  	sys_base = ioremap_nocache(0x40460000, 0x10000);
-	__raw_writel(__raw_readl(sys_base+0x20C) | (1 << 12),sys_base+0x20C);  // Uart CLK @ APBCLK0
+	__raw_writel(__raw_readl(sys_base+0x20C) | (0x3fff << 12),sys_base+0x20C);  // Uart CLK @ APBCLK0
 	__raw_writel(__raw_readl(sys_base+0x220) & ~(3 << 16),sys_base+0x220); // Uart CLK from HXT
-	//__raw_writel(2,(void *)REG_UART0_IER);		// Enable TX empty interrupt
 
 	/* UART0 multi-function */
 	__raw_writel( (__raw_readl(sys_base+0xA4) & ~0xff000000) | 0x11000000,sys_base+0xA4);
 
-	// UART0 multi-function  PF11,PF12
-	//__raw_writel((__raw_readl(NUA3500_VA_GCR+0x9C)&0xfff00fff) | 0x11000,(NUA3500_VA_GCR+0x9C));
 	if (!first)
 		return;
 	first = 0;
@@ -1255,15 +728,11 @@ static void __init nua3500serial_init_ports(void)
 		up->port.ops = &nua3500serial_ops;
 		up->port.iobase = (long)(0x40700000 + (i*0x10000));
 		up->port.membase = ioremap_nocache(up->port.iobase, 0x10000);
-		uart0_base = up->port.membase;
-		//if (!up->port.membase)
-		//	release_mem_region(up->port.membase, 0x10000);
-		if(i==0)
-		{	
-			printk("up->port.membase=0x%08x\n",up->port.membase);
-			__raw_writel(__raw_readl(up->port.membase+0xc) | 0x07,up->port.membase+0xc);
-			__raw_writel(0x3000000E,up->port.membase+0x24);
-		}
+
+		// for emulation: set baud-rate 9600
+		__raw_writel(__raw_readl(up->port.membase+0xc) | 0x07,up->port.membase+0xc);
+		__raw_writel(0x3000000E,up->port.membase+0x24);
+
 		up->port.uartclk = 12000000;
 
 	}
@@ -1282,8 +751,8 @@ void nua3500console_write(int ch){
 	struct uart_nua3500_port *up = &nua3500serial_ports[0];
 	if(up->port.membase!=NULL)
 	{
-        	while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));
-       		serial_out(up, UART_REG_THR, ch);
+		while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));
+		serial_out(up, UART_REG_THR, ch);
 	}
 
 }
@@ -1297,7 +766,6 @@ EXPORT_SYMBOL(nua3500console_write);
  */
 static void nua3500serial_console_write(struct console *co, const char *s, unsigned int count)
 {
-#if 1
 	struct uart_nua3500_port *up = &nua3500serial_ports[co->index];
 	unsigned long flags;
 	unsigned int ier;
@@ -1320,29 +788,12 @@ static void nua3500serial_console_write(struct console *co, const char *s, unsig
 	serial_out(up, UART_REG_IER, ier);
 
 	local_irq_restore(flags);
-#else
-	int i = count;
-	char *ptr = s;
-	struct uart_nua3500_port *up = &nua3500serial_ports[0];
-	while(i--)
-	{
-		while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));  //waits for TX_FULL bit is clear
-		serial_out(up, UART_REG_THR, *ptr);
-		if(*ptr == '\n')
-		{
-			while ((serial_in(up,UART_REG_FSR) &TX_EMPTY));
-			serial_out(up,UART_REG_THR, '\r');
-		}
-
-		ptr++;
-	}
-#endif
 }
 
 static int __init nua3500serial_console_setup(struct console *co, char *options)
 {
 	struct uart_port *port;
-	int baud = 9600;
+	int baud = 9600; // for emulator
 	int bits = 8;
 	int parity = 'n';
 	int flow = 'n';
@@ -1421,183 +872,11 @@ void nua3500serial_resume_port(int line)
 	uart_resume_port(&nua3500serial_reg, &up->port);
 }
 
-#ifndef CONFIG_OF
-static int nua3500serial_pinctrl(struct platform_device *pdev)
-{
-	struct pinctrl *p = NULL;
-	int retval = 0;
-
-	if(pdev->id == 1) {
-#if defined (CONFIG_NUA3500_UART1_PA)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart1-PA");
-#elif defined (CONFIG_NUA3500_UART1_PC)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart1-PC");
-#elif defined (CONFIG_NUA3500_UART1_PF)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart1-PF");
-#elif defined (CONFIG_NUA3500_UART1_FC_PC)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart1-fc-PC");
-#elif defined (CONFIG_NUA3500_UART1_FC_PF)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart1-fc-PF");
-#endif
-
-		if (IS_ERR(p)) {
-			dev_err(&pdev->dev, "unable to reserve pin\n");
-			retval = PTR_ERR(p);
-		}
-	} else if(pdev->id == 2) {
-#if defined (CONFIG_NUA3500_UART2_PA)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart2-PA");
-#elif defined (CONFIG_NUA3500_UART2_PG)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart2-PG");
-#elif defined (CONFIG_NUA3500_UART2_PD)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart2-PD");
-#elif defined (CONFIG_NUA3500_UART2_FC_PA)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart2-fc-PA");
-#elif defined (CONFIG_NUA3500_UART2_FC_PG)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart2-fc-PG");
-#elif defined (CONFIG_NUA3500_UART2_FC_PA_PB)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart2-fc-PA_PB");
-#endif
-
-		if (IS_ERR(p)) {
-			dev_err(&pdev->dev, "unable to reserve pin\n");
-			retval = PTR_ERR(p);
-		}
-	} else if(pdev->id == 3) {
-#if defined (CONFIG_NUA3500_UART3_PC)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart3-PC");
-#elif defined (CONFIG_NUA3500_UART3_PB)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart3-PB");
-#elif defined (CONFIG_NUA3500_UART3_PD)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart3-PD");
-#elif defined (CONFIG_NUA3500_UART3_PB_PF)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart3-PB_PF");
-#elif defined (CONFIG_NUA3500_UART3_PF)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart3-PF");
-#elif defined (CONFIG_NUA3500_UART3_FC_PB)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart3-fc-PB");
-#elif defined (CONFIG_NUA3500_UART3_FC_PD)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart3-fc-PD");
-#elif defined (CONFIG_NUA3500_UART3_FC_PF)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart3-fc-PF");
-#endif
-
-		if (IS_ERR(p)) {
-			dev_err(&pdev->dev, "unable to reserve pin\n");
-			retval = PTR_ERR(p);
-		}
-	} else if(pdev->id == 4) {
-#if defined (CONFIG_NUA3500_UART4_PC)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart4-PC");
-#elif defined (CONFIG_NUA3500_UART4_PD)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart4-PD");
-#elif defined (CONFIG_NUA3500_UART4_PE)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart4-PE");
-#elif defined (CONFIG_NUA3500_UART4_FC_PD)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart4-fc-PD");
-#elif defined (CONFIG_NUA3500_UART4_FC_PE)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart4-fc-PE");
-#endif
-
-		if (IS_ERR(p)) {
-			dev_err(&pdev->dev, "unable to reserve pin\n");
-			retval = PTR_ERR(p);
-		}
-	} else if(pdev->id == 5) {
-#if defined (CONFIG_NUA3500_UART5_PG_0)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart5-PG_0");
-#elif defined (CONFIG_NUA3500_UART5_PD)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart5-PD");
-#elif defined (CONFIG_NUA3500_UART5_PG_1)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart5-PG_1");
-#elif defined (CONFIG_NUA3500_UART5_FC_PG_0)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart5-fc-PG_0");
-#elif defined (CONFIG_NUA3500_UART5_FC_PG_1)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart5-fc-PG_1");
-#endif
-
-		if (IS_ERR(p)) {
-			dev_err(&pdev->dev, "unable to reserve pin\n");
-			retval = PTR_ERR(p);
-		}
-	} else if(pdev->id == 6) {
-#if defined (CONFIG_NUA3500_UART6_PA)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart6-PA");
-#elif defined (CONFIG_NUA3500_UART6_PD)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart6-PD");
-#elif defined (CONFIG_NUA3500_UART6_PE)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart6-PE");
-#elif defined (CONFIG_NUA3500_UART6_FC_PA)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart6-fc-PA");
-#elif defined (CONFIG_NUA3500_UART6_FC_PD)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart6-fc-PD");
-#endif
-
-		if (IS_ERR(p)) {
-			dev_err(&pdev->dev, "unable to reserve pin\n");
-			retval = PTR_ERR(p);
-		}
-	} else if(pdev->id == 7) {
-#if defined (CONFIG_NUA3500_UART7_PA)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart7-PA");
-#elif defined (CONFIG_NUA3500_UART7_PB)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart7-PB");
-#elif defined (CONFIG_NUA3500_UART7_PC)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart7-PC");
-#elif defined (CONFIG_NUA3500_UART7_PF)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart7-PF");
-#elif defined (CONFIG_NUA3500_UART7_FC_PB)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart7-fc-PB");
-#elif defined (CONFIG_NUA3500_UART7_FC_PF)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart7-fc-PF");
-#endif
-
-		if (IS_ERR(p)) {
-			dev_err(&pdev->dev, "unable to reserve pin\n");
-			retval = PTR_ERR(p);
-		}
-	} else if(pdev->id == 8) {
-#if defined (CONFIG_NUA3500_UART8_PA)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart8-PA");
-#elif defined (CONFIG_NUA3500_UART8_PB)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart8-PB");
-#elif defined (CONFIG_NUA3500_UART8_PC)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart8-PC");
-#elif defined (CONFIG_NUA3500_UART8_FC_PA_PG)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart8-fc-PA_PG");
-#elif defined (CONFIG_NUA3500_UART8_FC_PC)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart8-fc-PC");
-#endif
-
-		if (IS_ERR(p)) {
-			dev_err(&pdev->dev, "unable to reserve pin\n");
-			retval = PTR_ERR(p);
-		}
-	} else if(pdev->id == 9) {
-#if defined (CONFIG_NUA3500_UART9_PB)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart9-PB");
-#elif defined (CONFIG_NUA3500_UART9_PE_0)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart9-PE_0");
-#elif defined (CONFIG_NUA3500_UART9_PE_1)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart9-PE_1");
-#elif defined (CONFIG_NUA3500_UART9_FC_PE)
-		p = devm_pinctrl_get_select(&pdev->dev, "uart9-fc-PE");
-#endif
-
-		if (IS_ERR(p)) {
-			dev_err(&pdev->dev, "unable to reserve pin\n");
-			retval = PTR_ERR(p);
-		}
-	}
-
-	return retval;
-}
-#endif
 
 void nua3500serial_set_clock(struct uart_nua3500_port *up)
 {
-#if 1 //schung todo
-#else
+
+#if 0 // To Do: Config clock
 	struct clk *clkmux;
 	struct clk *upll_clk;
 
@@ -1633,185 +912,9 @@ void nua3500serial_set_clock(struct uart_nua3500_port *up)
 	}
 #endif
 
-#ifdef CONFIG_NUA3500_UART2
-	if(up->port.line == 2) {
-		clk = clk_get(NULL, "uart2");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clk = clk_get(NULL, "uart2_eclk");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clkmux = clk_get(NULL, "uart2_eclk_mux");
-		upll_clk = clk_get(NULL, "upll");
-		clk_set_parent(clkmux, upll_clk);
-
-		clk = clk_get(NULL, "uart2_eclk_div");
-
-		//clk_set_rate(clk, 100000000);
-		clk_set_rate(clk, 150000000);
-		up->port.uartclk = clk_get_rate(clk);
-	}
-#endif
-
-#ifdef CONFIG_NUA3500_UART3
-	if(up->port.line == 3) {
-		clk = clk_get(NULL, "uart3");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clk = clk_get(NULL, "uart3_eclk");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clkmux = clk_get(NULL, "uart3_eclk_mux");
-		upll_clk = clk_get(NULL, "upll");
-		clk_set_parent(clkmux, upll_clk);
-
-		clk = clk_get(NULL, "uart3_eclk_div");
-
-		//clk_set_rate(clk, 100000000);
-		clk_set_rate(clk, 150000000);
-		up->port.uartclk = clk_get_rate(clk);
-	}
-#endif
-
-#ifdef CONFIG_NUA3500_UART4
-	if(up->port.line == 4) {
-		clk = clk_get(NULL, "uart4");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clk = clk_get(NULL, "uart4_eclk");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clkmux = clk_get(NULL, "uart4_eclk_mux");
-		upll_clk = clk_get(NULL, "upll");
-		clk_set_parent(clkmux, upll_clk);
-
-		clk = clk_get(NULL, "uart4_eclk_div");
-
-		//clk_set_rate(clk, 100000000);
-		clk_set_rate(clk, 150000000);
-		up->port.uartclk = clk_get_rate(clk);
-	}
-#endif
-
-#ifdef CONFIG_NUA3500_UART5
-	if(up->port.line == 5) {
-		clk = clk_get(NULL, "uart5");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clk = clk_get(NULL, "uart5_eclk");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clkmux = clk_get(NULL, "uart5_eclk_mux");
-		upll_clk = clk_get(NULL, "upll");
-		clk_set_parent(clkmux, upll_clk);
-
-		clk = clk_get(NULL, "uart5_eclk_div");
-
-		//clk_set_rate(clk, 100000000);
-		clk_set_rate(clk, 150000000);
-		up->port.uartclk = clk_get_rate(clk);
-	}
-#endif
-
-#ifdef CONFIG_NUA3500_UART6
-	if(up->port.line == 6) {
-		clk = clk_get(NULL, "uart6");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clk = clk_get(NULL, "uart6_eclk");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clkmux = clk_get(NULL, "uart6_eclk_mux");
-		upll_clk = clk_get(NULL, "upll");
-		clk_set_parent(clkmux, upll_clk);
-
-		clk = clk_get(NULL, "uart6_eclk_div");
-
-		//clk_set_rate(clk, 100000000);
-		clk_set_rate(clk, 150000000);
-		up->port.uartclk = clk_get_rate(clk);
-	}
-#endif
-
-#ifdef CONFIG_NUA3500_UART7
-	if(up->port.line == 7) {
-		clk = clk_get(NULL, "uart7");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clk = clk_get(NULL, "uart7_eclk");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clkmux = clk_get(NULL, "uart7_eclk_mux");
-		upll_clk = clk_get(NULL, "upll");
-		clk_set_parent(clkmux, upll_clk);
-
-		clk = clk_get(NULL, "uart7_eclk_div");
-
-		//clk_set_rate(clk, 100000000);
-		clk_set_rate(clk, 150000000);
-		up->port.uartclk = clk_get_rate(clk);
-	}
-#endif
-
-#ifdef CONFIG_NUA3500_UART8
-	if(up->port.line == 8) {
-		clk = clk_get(NULL, "uart8");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clk = clk_get(NULL, "uart8_eclk");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clkmux = clk_get(NULL, "uart8_eclk_mux");
-		upll_clk = clk_get(NULL, "upll");
-		clk_set_parent(clkmux, upll_clk);
-
-		clk = clk_get(NULL, "uart8_eclk_div");
-
-		//clk_set_rate(clk, 100000000);
-		clk_set_rate(clk, 150000000);
-		up->port.uartclk = clk_get_rate(clk);
-	}
-#endif
-
-#ifdef CONFIG_NUA3500_UART9
-	if(up->port.line == 9) {
-		clk = clk_get(NULL, "uart9");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clk = clk_get(NULL, "uart9_eclk");
-		clk_prepare(clk);
-		clk_enable(clk);
-
-		clkmux = clk_get(NULL, "uart9_eclk_mux");
-		upll_clk = clk_get(NULL, "upll");
-		clk_set_parent(clkmux, upll_clk);
-
-		clk = clk_get(NULL, "uart9_eclk_div");
-
-		//clk_set_rate(clk, 100000000);
-		clk_set_rate(clk, 150000000);
-		up->port.uartclk = clk_get_rate(clk);
-	}
-#endif
 #endif
 }
 
-#if defined(CONFIG_OF)
 static int  get_uart_port_number(struct platform_device *pdev)
 {
 	u32   val32[2];
@@ -1823,166 +926,49 @@ static int  get_uart_port_number(struct platform_device *pdev)
 
 	return val32[0];
 }
-#endif
 
 /*
  * Register a set of serial devices attached to a platform device.  The
  * list is terminated with a zero flags entry, which means we expect
  * all entries to have at least UPF_BOOT_AUTOCONF set.
  */
- //#define SCHUNG_T
 static int nua3500serial_probe(struct platform_device *pdev)
 {
-	int ip_irq;
-#ifdef SCHUNG_T
-	struct resource *resource;
-#else
-	struct resource *regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	//struct resource *irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-
-#endif
-	int virt_irq,phys_irq;
-	unsigned char * __iomem ip_base;
 	struct uart_nua3500_port *up;
-	struct device_node *np = pdev->dev.of_node;
-//	struct device_node *np;
 	int ret, i;
 
-//	np = of_find_compatible_node(NULL, NULL,
-//							 "nuvoton,nua3500-uart");
-
-	
-//	virt_irq = irq_of_parse_and_map(np,
-//						   0);
-//	phys_irq = irq_of_parse_and_map(np,
-//						   1);
-//	printk("=====>  virt_irq=%d,phys_irq=%d  <=====\n");
-
-	//ip_base = of_iomap(np, 0);
-	//printk("ip_base=0x%08x\n",(u32)ip_base);
-	//ip_irq =irq_of_parse_and_map(np,0);
-	//printk("ip_irq=%d\n",ip_irq);
-	//of_node_put(np);
-//#if defined(CONFIG_OF)
-//	struct pinctrl *pinctrl;
-//	u32   val32[2];
-//#else
-//	int retval;
-//	struct plat_nua3500serial_port *p = pdev->dev.platform_data;
-//#endif
-
-//#if defined(CONFIG_OF)
-//	#if 0 //schung todo
-//	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
-//	if (IS_ERR(pinctrl)) {
-//		return PTR_ERR(pinctrl);
-//	}
-//	#endif
-//#else
-//	retval = nua3500serial_pinctrl(pdev);
-//	if(retval != 0)
-//		return retval;
-//#endif
-
-//#if defined(CONFIG_OF)
-//	i = get_uart_port_number(pdev);
-//	if (i < 0)
-//		return -EINVAL;
-//#else
-//	i = pdev->id;
-//#endif
-	i = 0;
+	//struct pinctrl *pinctrl;  // To Do:Set MFP
+	u32   val32[2];
+
+#if 0 // To Do: Set MFP
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl)) {
+		return PTR_ERR(pinctrl);
+	}
+#endif
+
+	i = get_uart_port_number(pdev);
+	if (i < 0)
+		return -EINVAL;
+
 	up = &nua3500serial_ports[i];
 
 	up->port.line = i;
 
-//	nua3500serial_set_clock(up);
-
-//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
-//#if defined(CONFIG_OF)
-//	if (of_property_read_u32_array(pdev->dev.of_node, "pdma-enable", val32, 1) != 0) {
-//		printk("%s - can not get map-addr!\n", __func__);
-//		return -EINVAL;
-//	}
-//
-//	if(val32[0] == 1) set_pdma_flag(up, i);
-//
-//#else
-//	set_pdma_flag(up, i);
-//#endif
-//#endif
-
-//#if defined(CONFIG_OF)
-	/*--------------------------------------------------------------*/
-	/*  get UART register map address from DTB                      */
-	/*--------------------------------------------------------------*/
-//	if (of_property_read_u32_array(pdev->dev.of_node, "map-addr", val32, 1) != 0) {
-//		printk("%s - can not get map-addr!\n", __func__);
-//		return -EINVAL;
-//	}
-
-//	up->port.membase = (unsigned char __iomem *)val32[0];
-
-//	up->port.iobase         = (unsigned long)up->port.membase;
-
-	//up->port.iobase = pdev->hpa.start + (i * 0x10000);
-#ifdef SCHUNG_T
-	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	up->port.membase =  resource->start;
-	printk("up->port.membase=0x%08x\n",(u32)up->port.membase);
-	up->port.irq            = platform_get_irq(pdev, 0); // ip_irq;//91;
-	printk("up->port.irq=0x%08x\n",(u32)up->port.irq);
-#else
-	//if (!regs || !irq) {
-	//	printk("ERROR\n");
-	//	dev_err(&pdev->dev, "no registers/irq defined\n");
-	//	return -EINVAL;
-	//}
-	//printk("devm_ioremap  regs->start=0x%08x\n", regs->start);
-//up->port.membase = devm_ioremap_nocache(&pdev->dev, regs->start, resource_size(regs));	
-	//up->port.membase = ioremap_nocache(regs->start, 0x10000);
-//printk("up->port.membase=0x%08x\n",(u32)up->port.membase);
-	//up->port.irq =irq->start;
-	up->port.irq=platform_get_irq(pdev, 0);
-	printk("up->port.irq=0x%08x\n",(u32)up->port.irq);
+	nua3500serial_set_clock(up);
 
-//		up->port.irq=platform_get_irq(pdev, 1);
-//	printk("up->port.irq=0x%08x  <<<2\n",(u32)up->port.irq);
-//	printk("up->port.irq2=0x%08x\n",(u32)up->port.irq);
+	if (of_property_read_u32_array(pdev->dev.of_node, "pdma-enable", val32, 1) != 0) {
+		printk("%s - can not get map-addr!\n", __func__);
+		return -EINVAL;
+	}
 
-//printk("2up->port.membase=0x%08x\n",(u32)devm_ioremap_nocache(&pdev->dev, regs->start, resource_size(regs)));
-//printk("2up->port.irq=0x%08x\n",(u32)platform_get_irq(pdev, 0));
+	// Set PDMA Flag
+	if(val32[0] == 1) set_pdma_flag(up, i);
 
-#endif
+	up->port.irq=platform_get_irq(pdev, 0);
 	up->port.dev            = &pdev->dev;
 	up->port.flags          = ASYNC_BOOT_AUTOCONF;
 
-	//ret = request_irq(91, nua3500serial_interrupt, 0, "nua3500_serial", up);
-
-	//if (ret) {
-	//	printk("request irq failed... %d\n",ret);
-		//return retval;
-	//}
-
-//#else
-//	up->port.membase        = p->membase;
-
-//	up->port.iobase         = p->iobase;
-//	up->port.irq            = p->irq;
-	//up->port.uartclk        = p->uartclk;
-//	up->port.mapbase        = p->mapbase;
-//	up->port.private_data   = p->private_data;
-//	up->port.dev            = &pdev->dev;
-//	up->port.flags          = ASYNC_BOOT_AUTOCONF;
-
-	/* Possibly override default I/O functions.  */
-//	if (p->serial_in)
-//		up->port.serial_in = p->serial_in;
-//	if (p->serial_out)
-//		up->port.serial_out = p->serial_out;
-
-//#endif
-
 	up->port.rs485_config = nua3500serial_config_rs485;
 
 	ret = uart_add_one_port(&nua3500serial_reg, &up->port);
@@ -2015,13 +1001,9 @@ static int nua3500serial_suspend(struct platform_device *dev, pm_message_t state
 
 	struct uart_nua3500_port *up;
 
-#if defined(CONFIG_OF)
 	i = get_uart_port_number(dev);
 	if (i < 0)
 		return i;
-#else
-	i = dev->id;
-#endif
 
 	up = &nua3500serial_ports[i];
 
@@ -2126,9 +1108,7 @@ static struct platform_driver nua3500serial_driver = {
 	{
 		.name   = "nua3500-uart",
 		.owner  = THIS_MODULE,
-#if defined(CONFIG_OF)
 		.of_match_table = of_match_ptr(nua3500_serial_of_match),
-#endif
 	},
 };
 
@@ -2139,9 +1119,7 @@ static int __init nua3500serial_init(void)
 	ret = uart_register_driver(&nua3500serial_reg);
 	if (ret)
 		return ret;
-#ifndef CONFIG_SERIAL_NUA3500_CONSOLE
-	nua3500serial_init_ports();
-#endif
+
 	ret = platform_driver_register(&nua3500serial_driver);
 	if (ret)
 		uart_unregister_driver(&nua3500serial_reg);
-- 
2.0.3

