From 67c5a4111532d32f81d18cda2cf97ec185be1272 Mon Sep 17 00:00:00 2001
From: schung <schung@nuvoton.com>
Date: Tue, 7 Jul 2020 16:11:05 +0800
Subject: [PATCH 1/7] Add NUA3500

Change-Id: Id3b19bf83efc75211f27c66932bf0e57fe1e4279
---
 arch/arm64/Kconfig.platforms                |   11 +
 arch/arm64/boot/dts/Makefile                |    1 +
 arch/arm64/boot/dts/nuvoton/Makefile        |    6 +
 arch/arm64/boot/dts/nuvoton/nua3500-evb.dts |   25 +
 arch/arm64/boot/dts/nuvoton/nua3500.dtsi    |  227 +++
 arch/arm64/configs/nua3500_defconfig        | 2283 +++++++++++++++++++++++++++
 drivers/tty/serial/Kconfig                  |   15 +
 drivers/tty/serial/Makefile                 |    1 +
 drivers/tty/serial/nua3500_serial.c         | 2167 +++++++++++++++++++++++++
 drivers/tty/serial/nua3500_serial.h         |   85 +
 include/uapi/linux/serial_core.h            |    3 +
 13 files changed, 4835 insertions(+)
 create mode 100755 arch/arm64/boot/dts/nuvoton/Makefile
 create mode 100755 arch/arm64/boot/dts/nuvoton/nua3500-evb.dts
 create mode 100755 arch/arm64/boot/dts/nuvoton/nua3500.dtsi
 create mode 100755 arch/arm64/configs/nua3500_defconfig
 create mode 100755 drivers/tty/serial/nua3500_serial.c
 create mode 100755 drivers/tty/serial/nua3500_serial.h

diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
index 16d7614..0792a8f 100644
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -298,4 +298,15 @@ config ARCH_ZYNQMP
 	help
 	  This enables support for Xilinx ZynqMP Family
 
+config ARCH_NUA3500
+	bool "Nuvoton NUA3500 SOC Family"
+	select PINCTRL
+	select PINCTRL_NUA3500
+	select PM
+	select GPIOLIB
+	select SOC_BUS
+	help
+	  This enables support for Nuvoton NUA3500 SOC Family.
+
+
 endmenu
diff --git a/arch/arm64/boot/dts/Makefile b/arch/arm64/boot/dts/Makefile
index f19b762..490c782 100644
--- a/arch/arm64/boot/dts/Makefile
+++ b/arch/arm64/boot/dts/Makefile
@@ -28,3 +28,4 @@ subdir-y += synaptics
 subdir-y += ti
 subdir-y += xilinx
 subdir-y += zte
+subdir-y += nuvoton
diff --git a/arch/arm64/boot/dts/nuvoton/Makefile b/arch/arm64/boot/dts/nuvoton/Makefile
new file mode 100755
index 0000000..72c91bf
--- /dev/null
+++ b/arch/arm64/boot/dts/nuvoton/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_ARCH_NUA3500)    += nua3500-evb.dtb
+
+always          := $(dtb-y)
+clean-files     := *.dtb
+
diff --git a/arch/arm64/boot/dts/nuvoton/nua3500-evb.dts b/arch/arm64/boot/dts/nuvoton/nua3500-evb.dts
new file mode 100755
index 0000000..fdb93bf
--- /dev/null
+++ b/arch/arm64/boot/dts/nuvoton/nua3500-evb.dts
@@ -0,0 +1,25 @@
+/*
+ * Device Tree Source for NUA3500
+ *
+ * Copyright (C) 2020 Nuvoton Technology Corp.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+
+#include "nua3500.dtsi"
+
+/ {
+	model = "Nuvoton NUA3500-EVB";
+
+	chosen {
+		bootargs = "root=/dev/ram0 rw console=ttyS0,9600n8 init=/bin/busybox mem=128M initrd=0x85000000,16M";
+//		bootargs = "root=/dev/ram0 console=ttyS0,9600n8 rdinit=/linuxrc mem=64M";
+	};
+};
diff --git a/arch/arm64/boot/dts/nuvoton/nua3500.dtsi b/arch/arm64/boot/dts/nuvoton/nua3500.dtsi
new file mode 100755
index 0000000..b4653b8
--- /dev/null
+++ b/arch/arm64/boot/dts/nuvoton/nua3500.dtsi
@@ -0,0 +1,227 @@
+/*
+ * Device Tree Source for NUA3500
+ *
+ * Copyright (C) 2020 Nuvoton Technology Corp.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+//#define ENABLE_PSCI
+/{
+	compatible = "nuvoton,nua3500";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		/* We have 1 clusters having 2 Cortex-A35 cores */
+		cpu0: cpu@0 {
+                        device_type = "cpu";
+                        compatible = "arm,cortex-a35";
+                        reg = <0x0 0x0>;
+			#ifdef ENABLE_PSCI
+			enable-method = "psci";
+			#else
+                        enable-method = "spin-table";
+                        cpu-release-addr = <0x0 0x8000fff8>;
+			#endif
+			next-level-cache = <&L2_0>;
+                };
+#if 0
+                cpu1: cpu@1 {
+                        device_type = "cpu";
+                        compatible = "arm,cortex-a35";
+                        reg = <0x0 0x1>;
+			#ifdef ENABLE_PSCI
+			enable-method = "psci";
+			#else
+                        enable-method = "spin-table";
+                        cpu-release-addr = <0x0 0x8000fff8>;
+			#endif
+			next-level-cache = <&L2_0>;
+                };
+#endif
+		L2_0: l2-cache0 {
+			compatible = "cache";
+			cache-level = <2>;
+		};
+	};
+
+#if 0
+        pmu {
+                interrupt-affinity = <&cpu0>, <&cpu1>;
+        };
+#endif
+
+#ifdef ENABLE_PSCI
+	psci {
+                compatible = "arm,psci";
+		cpu_on = <0xC4000003>;
+                method = "smc";
+        };
+#endif
+
+#if 0
+        pmu {
+                compatible = "arm,armv8-pmuv3";
+                interrupts = <GIC_PPI 7 (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_HIGH)>;
+		interrupt-affinity = <&A35_0>, <&A35_1>;
+        };
+#endif
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x00000000 0x80000000 0 0x8000000>; /* DRAM space - 1, size : 1 GB DRAM */
+		//reg = <0x00000000 0x80000000 0 0x4000000>; /* DRAM space - 1, size : 64MB */
+	};
+
+        timer {
+                compatible = "arm,armv8-timer";
+                interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>, /* Physical Secure */
+                                <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>, /* Physical Non-Secure */
+                                <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>, /* Virtual */
+                                <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_LOW)>; /* Hypervisor */
+                clock-frequency = <12000000>;
+                interrupt-parent = <&gic>;
+        };
+
+	gic: interrupt-controller@50800000 {
+		compatible = "arm,gic-400";
+		#interrupt-cells = <3>;
+		interrupt-parent = <&gic>;
+		interrupt-controller;
+		reg =   <0x0 0x50801000 0 0x1000>, /* GICD */
+                        <0x0 0x50802000 0 0x2000>, /* GICC */
+                        <0x0 0x50804000 0 0x2000>, /* GICH */
+                        <0x0 0x50806000 0 0x2000>; /* GICV */
+		interrupts = <GIC_PPI 9 (GIC_CPU_MASK_RAW(0x13) | IRQ_TYPE_LEVEL_HIGH)>;
+	};
+
+#if 1
+	uart0: serial@40700000 {
+		compatible = "nuvoton,nua3500-uart";
+		reg = <0x0 0x40700000 0x0 0x10000>;
+		interrupts = <GIC_SPI 59 IRQ_TYPE_EDGE_RISING>;
+		status = "okay";
+	};
+#endif
+
+#if 1
+        sdhci0: sdhci@40180000 {
+		compatible = "snps,dwcmshc-sdhci";
+		reg = <0x0 0x40180000 0x0 0x2000>;
+		interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+		/* clocks = <&emmcclk>; */
+		bus-width = <4>;
+		max-frequency = <200000000>;
+		sdhci,auto-cmd12;
+		no-1-8-v;
+		status = "okay";
+        };
+#endif
+#if 0
+        sdhci1: sdhci@40190000 {
+		compatible = "snps,dwcmshc-sdhci";
+		reg = <0x0 0x40190000 0x0 0x2000>;
+		interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+		bus-width = <4>;
+		max-frequency = <100000000>;
+		status = "disabled";
+		no-1-8-v;
+	};
+#if 0
+	dma0: dma@40080000 {
+		compatible = "nuvoton,nua3500-dma";
+		reg = <0x0 0x40080000 0x0 0x2000>;
+		interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+		status = "disabled";
+	};
+	dma1: dma@40090000 {
+		compatible = "nuvoton,nua3500-dma";
+		reg = <0x0 0x40090000 0x0 0x2000>;
+		interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>;
+		status = "disabled";
+	};
+	dma2: dma@400A0000 {
+		compatible = "nuvoton,nua3500-dma";
+		reg = <0x0 0x400A0000 0x0 0x2000>;
+		interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+		status = "disabled";
+	};
+	dma3: dma@400B0000 {
+		compatible = "nuvoton,nua3500-dma";
+		reg = <0x0 0x400B0000 0x0 0x2000>;
+		interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+		status = "disabled";
+	};
+#else
+	dma@40080000 {
+		compatible = "nuvoton,nuc980-dma";
+		reg = <0x0 0x40080000 0x0 0x2000>,
+					<0x0 0x40090000 0x0 0x2000>,
+					<0x0 0x400A0000 0x0 0x2000>,
+					<0x0 0x400B0000 0x0 0x2000>;
+		interrupts =	<GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>,
+									<GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+									<GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
+									<GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+		status = "okay";
+	};
+#endif
+
+	sdhci0: sdhci@40180000 {
+		compatible = "snps,dwcmshc-sdhci";
+		reg = <0x0 0x40180000 0x0 0x2000>;
+		interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+		/* clocks = <&emmcclk>; */
+		bus-width = <8>;
+		sdhci,auto-cmd12;
+	};
+	sdhci1: sdhci@40190000 {
+		compatible = "snps,dwcmshc-sdhci";
+		reg = <0x0 0x40190000 0x0 0x2000>;
+		interrupts = <GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH>;
+		/* clocks = <&emmcclk>; */
+		bus-width = <8>;
+		sdhci,auto-cmd12;
+	};
+	gmac0: gmac@40120000 {
+		compatible = "nuvoton,nua3500-gmac";
+		reg = <0x0 0x40120000 0x0 0x10000>;
+		interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "gmac0irq";
+		status = "disabled";
+		reset-names = "stmmaceth";
+		clock-names = "stmmaceth";
+		mdio {
+			compatible = "snps,dwmac-mdio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+	};
+	gmac1: gmac@40130000 {
+		compatible = "nuvoton,nua3500-gmac";
+		reg = <0x0 0x40130000 0x0 0x10000>;
+		interrupts = <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "gmac1irq";
+		status = "disabled";
+		reset-names = "stmmaceth";
+		clock-names = "stmmaceth";
+		mdio {
+			compatible = "snps,dwmac-mdio";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+	};
+#endif
+};
diff --git a/arch/arm64/configs/nua3500_defconfig b/arch/arm64/configs/nua3500_defconfig
new file mode 100755
index 0000000..52c429a
--- /dev/null
+++ b/arch/arm64/configs/nua3500_defconfig
@@ -0,0 +1,2283 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm64 5.4.50 Kernel Configuration
+#
+
+#
+# Compiler: aarch64-linux-gnu-gcc (Linaro GCC 7.3-2018.05) 7.3.1 20180425 [linaro-7.3-2018.05 revision d29120a424ecfbc167ef90065c0eeb7f91977701]
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=70301
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_CAN_LINK=y
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+CONFIG_THREAD_INFO_IN_TASK=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_BUILD_SALT=""
+CONFIG_DEFAULT_HOSTNAME="localhost"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_USELIB is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_DEBUGFS=y
+# end of IRQ subsystem
+
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+# CONFIG_NO_HZ_IDLE is not set
+CONFIG_NO_HZ_FULL=y
+CONFIG_CONTEXT_TRACKING=y
+# CONFIG_CONTEXT_TRACKING_FORCE is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+# end of Timers subsystem
+
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_VIRT_CPU_ACCOUNTING=y
+CONFIG_VIRT_CPU_ACCOUNTING_GEN=y
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_PSI is not set
+# end of CPU/Task time and stats accounting
+
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+CONFIG_RCU_NOCB_CPU=y
+# end of RCU Subsystem
+
+# CONFIG_IKCONFIG is not set
+# CONFIG_IKHEADERS is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+
+#
+# Scheduler features
+#
+# end of Scheduler features
+
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+# CONFIG_NUMA_BALANCING is not set
+CONFIG_CGROUPS=y
+# CONFIG_MEMCG is not set
+# CONFIG_BLK_CGROUP is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_CGROUP_PERF is not set
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=".gz"
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+# CONFIG_BPF_SYSCALL is not set
+# CONFIG_USERFAULTFD is not set
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_RSEQ=y
+# CONFIG_DEBUG_RSEQ is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# end of Kernel Performance Events And Counters
+
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+CONFIG_PROFILING=y
+# end of General setup
+
+CONFIG_ARM64=y
+CONFIG_64BIT=y
+CONFIG_MMU=y
+CONFIG_ARM64_PAGE_SHIFT=12
+CONFIG_ARM64_CONT_SHIFT=4
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=33
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=16
+CONFIG_NO_IOPORT_MAP=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA32=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_SMP=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+
+#
+# Platform selection
+#
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_AGILEX is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_BCM2835 is not set
+# CONFIG_ARCH_BCM_IPROC is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_BITMAIN is not set
+# CONFIG_ARCH_BRCMSTB is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_K3 is not set
+# CONFIG_ARCH_LAYERSCAPE is not set
+# CONFIG_ARCH_LG1K is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_REALTEK is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_SEATTLE is not set
+# CONFIG_ARCH_STRATIX10 is not set
+# CONFIG_ARCH_SYNQUACER is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_SPRD is not set
+# CONFIG_ARCH_THUNDER is not set
+# CONFIG_ARCH_THUNDER2 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_XGENE is not set
+# CONFIG_ARCH_ZX is not set
+# CONFIG_ARCH_ZYNQMP is not set
+CONFIG_ARCH_NUA3500=y
+# end of Platform selection
+
+#
+# Kernel Features
+#
+
+#
+# ARM errata workarounds via the alternatives framework
+#
+# CONFIG_ARM64_ERRATUM_826319 is not set
+# CONFIG_ARM64_ERRATUM_827319 is not set
+# CONFIG_ARM64_ERRATUM_824069 is not set
+# CONFIG_ARM64_ERRATUM_819472 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_845719 is not set
+# CONFIG_ARM64_ERRATUM_843419 is not set
+# CONFIG_ARM64_ERRATUM_1024718 is not set
+CONFIG_ARM64_ERRATUM_1418040=y
+CONFIG_ARM64_ERRATUM_1165522=y
+CONFIG_ARM64_ERRATUM_1286807=y
+# CONFIG_ARM64_ERRATUM_1463225 is not set
+CONFIG_ARM64_ERRATUM_1542419=y
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+CONFIG_CAVIUM_ERRATUM_23144=y
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_CAVIUM_ERRATUM_30115 is not set
+CONFIG_CAVIUM_TX2_ERRATUM_219=y
+# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
+CONFIG_ARM64_WORKAROUND_REPEAT_TLBI=y
+# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
+# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
+# CONFIG_SOCIONEXT_SYNQUACER_PREITS is not set
+# CONFIG_HISILICON_ERRATUM_161600802 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_E1041 is not set
+CONFIG_FUJITSU_ERRATUM_010001=y
+# end of ARM errata workarounds via the alternatives framework
+
+CONFIG_ARM64_4K_PAGES=y
+# CONFIG_ARM64_16K_PAGES is not set
+# CONFIG_ARM64_64K_PAGES is not set
+# CONFIG_ARM64_VA_BITS_39 is not set
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_ARM64_VA_BITS=48
+CONFIG_ARM64_PA_BITS_48=y
+CONFIG_ARM64_PA_BITS=48
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+CONFIG_NUMA=y
+CONFIG_NODES_SHIFT=2
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_HOLES_IN_ZONE=y
+# CONFIG_HZ_100 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+CONFIG_HZ_1000=y
+CONFIG_HZ=1000
+CONFIG_SCHED_HRTICK=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+# CONFIG_SECCOMP is not set
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_KEXEC is not set
+# CONFIG_KEXEC_FILE is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_XEN is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+# CONFIG_UNMAP_KERNEL_AT_EL0 is not set
+CONFIG_HARDEN_BRANCH_PREDICTOR=y
+CONFIG_HARDEN_EL2_VECTORS=y
+CONFIG_ARM64_SSBD=y
+CONFIG_RODATA_FULL_DEFAULT_ENABLED=y
+# CONFIG_ARM64_SW_TTBR0_PAN is not set
+CONFIG_ARM64_TAGGED_ADDR_ABI=y
+CONFIG_COMPAT=y
+CONFIG_KUSER_HELPERS=y
+# CONFIG_ARMV8_DEPRECATED is not set
+
+#
+# ARMv8.1 architectural features
+#
+# CONFIG_ARM64_HW_AFDBM is not set
+# CONFIG_ARM64_PAN is not set
+CONFIG_ARM64_LSE_ATOMICS=y
+CONFIG_ARM64_VHE=y
+# end of ARMv8.1 architectural features
+
+#
+# ARMv8.2 architectural features
+#
+# CONFIG_ARM64_UAO is not set
+# CONFIG_ARM64_PMEM is not set
+CONFIG_ARM64_RAS_EXTN=y
+CONFIG_ARM64_CNP=y
+# end of ARMv8.2 architectural features
+
+#
+# ARMv8.3 architectural features
+#
+CONFIG_ARM64_PTR_AUTH=y
+# end of ARMv8.3 architectural features
+
+# CONFIG_ARM64_SVE is not set
+# CONFIG_ARM64_MODULE_PLTS is not set
+# CONFIG_ARM64_PSEUDO_NMI is not set
+# CONFIG_RANDOMIZE_BASE is not set
+# end of Kernel Features
+
+#
+# Boot options
+#
+CONFIG_CMDLINE=""
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_EFI is not set
+# end of Boot options
+
+CONFIG_SYSVIPC_COMPAT=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_PM_SLEEP_DEBUG=y
+CONFIG_PM_CLK=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# end of Power management options
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+# end of CPU Idle
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+# end of CPU Frequency scaling
+# end of CPU Power Management
+
+#
+# Firmware Drivers
+#
+CONFIG_ARM_SDE_INTERFACE=y
+# CONFIG_FIRMWARE_MEMMAP is not set
+CONFIG_HAVE_ARM_SMCCC=y
+CONFIG_ARM_PSCI_FW=y
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+# end of Tegra firmware driver
+# end of Firmware Drivers
+
+# CONFIG_VIRTUALIZATION is not set
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA256_ARM64=y
+# CONFIG_CRYPTO_SHA512_ARM64 is not set
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+# CONFIG_CRYPTO_SHA512_ARM64_CE is not set
+# CONFIG_CRYPTO_SHA3_ARM64 is not set
+# CONFIG_CRYPTO_SM3_ARM64_CE is not set
+# CONFIG_CRYPTO_SM4_ARM64_CE is not set
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64=y
+CONFIG_CRYPTO_AES_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=y
+# CONFIG_CRYPTO_CHACHA20_NEON is not set
+# CONFIG_CRYPTO_NHPOLY1305_NEON is not set
+# CONFIG_CRYPTO_AES_ARM64_BS is not set
+
+#
+# General architecture-dependent options
+#
+# CONFIG_KPROBES is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_FUNCTION_ERROR_INJECTION=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_KEEPINITRD=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_ARCH_HAS_SET_DIRECT_MAP=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_HAVE_ASM_MODVERSIONS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_FUNCTION_ARG_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE=y
+CONFIG_HAVE_RCU_TABLE_FREE=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_ARCH_STACKLEAK=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS=y
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS=11
+CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+CONFIG_64BIT_TIME=y
+CONFIG_COMPAT_32BIT_TIME=y
+CONFIG_HAVE_ARCH_VMAP_STACK=y
+CONFIG_VMAP_STACK=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_REFCOUNT_FULL=y
+CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=y
+# CONFIG_LOCK_EVENT_COUNTS is not set
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# end of GCOV-based kernel profiling
+
+CONFIG_PLUGIN_HOSTCC=""
+CONFIG_HAVE_GCC_PLUGINS=y
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+# end of Partition Types
+
+CONFIG_BLOCK_COMPAT=y
+CONFIG_BLK_PM=y
+
+#
+# IO Schedulers
+#
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+# end of IO Schedulers
+
+CONFIG_ARCH_INLINE_SPIN_TRYLOCK=y
+CONFIG_ARCH_INLINE_SPIN_TRYLOCK_BH=y
+CONFIG_ARCH_INLINE_SPIN_LOCK=y
+CONFIG_ARCH_INLINE_SPIN_LOCK_BH=y
+CONFIG_ARCH_INLINE_SPIN_LOCK_IRQ=y
+CONFIG_ARCH_INLINE_SPIN_LOCK_IRQSAVE=y
+CONFIG_ARCH_INLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_INLINE_SPIN_UNLOCK_BH=y
+CONFIG_ARCH_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_ARCH_INLINE_SPIN_UNLOCK_IRQRESTORE=y
+CONFIG_ARCH_INLINE_READ_LOCK=y
+CONFIG_ARCH_INLINE_READ_LOCK_BH=y
+CONFIG_ARCH_INLINE_READ_LOCK_IRQ=y
+CONFIG_ARCH_INLINE_READ_LOCK_IRQSAVE=y
+CONFIG_ARCH_INLINE_READ_UNLOCK=y
+CONFIG_ARCH_INLINE_READ_UNLOCK_BH=y
+CONFIG_ARCH_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_ARCH_INLINE_READ_UNLOCK_IRQRESTORE=y
+CONFIG_ARCH_INLINE_WRITE_LOCK=y
+CONFIG_ARCH_INLINE_WRITE_LOCK_BH=y
+CONFIG_ARCH_INLINE_WRITE_LOCK_IRQ=y
+CONFIG_ARCH_INLINE_WRITE_LOCK_IRQSAVE=y
+CONFIG_ARCH_INLINE_WRITE_UNLOCK=y
+CONFIG_ARCH_INLINE_WRITE_UNLOCK_BH=y
+CONFIG_ARCH_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_INLINE_WRITE_UNLOCK_IRQRESTORE=y
+CONFIG_INLINE_SPIN_TRYLOCK=y
+CONFIG_INLINE_SPIN_TRYLOCK_BH=y
+CONFIG_INLINE_SPIN_LOCK=y
+CONFIG_INLINE_SPIN_LOCK_BH=y
+CONFIG_INLINE_SPIN_LOCK_IRQ=y
+CONFIG_INLINE_SPIN_LOCK_IRQSAVE=y
+CONFIG_INLINE_SPIN_UNLOCK_BH=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE=y
+CONFIG_INLINE_READ_LOCK=y
+CONFIG_INLINE_READ_LOCK_BH=y
+CONFIG_INLINE_READ_LOCK_IRQ=y
+CONFIG_INLINE_READ_LOCK_IRQSAVE=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_BH=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK_IRQRESTORE=y
+CONFIG_INLINE_WRITE_LOCK=y
+CONFIG_INLINE_WRITE_LOCK_BH=y
+CONFIG_INLINE_WRITE_LOCK_IRQ=y
+CONFIG_INLINE_WRITE_LOCK_IRQSAVE=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_BH=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_ARCH_HAS_SYSCALL_WRAPPER=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+# CONFIG_SPARSEMEM_VMEMMAP is not set
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_HAVE_FAST_GUP=y
+CONFIG_ARCH_KEEP_MEMBLOCK=y
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+# CONFIG_MEMORY_FAILURE is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_DEFERRED_STRUCT_PAGE_INIT is not set
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_ARCH_HAS_PTE_DEVMAP=y
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+CONFIG_ARCH_HAS_PTE_SPECIAL=y
+# end of Memory Management options
+
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+# CONFIG_UNIX is not set
+# CONFIG_TLS is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_RAW_DIAG is not set
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# end of Network testing
+# end of Networking options
+
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+# CONFIG_FAILOVER is not set
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_ARM_AMBA=y
+CONFIG_HAVE_PCI=y
+# CONFIG_PCI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+# CONFIG_FW_LOADER_COMPRESS is not set
+# end of Firmware loader
+
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_SOC_BUS=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+# end of Generic Driver Options
+
+#
+# Bus devices
+#
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_SIMPLE_PM_BUS is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# end of Bus devices
+
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+
+#
+# Partition parsers
+#
+# CONFIG_MTD_AR7_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# end of Partition parsers
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+CONFIG_MTD_RAM=y
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# end of RAM/ROM/Flash chip drivers
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+CONFIG_MTD_PLATRAM=y
+# end of Mapping drivers for chip access
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+CONFIG_MTD_BLOCK2MTD=y
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# end of Self-contained MTD device drivers
+
+# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_RAW_NAND is not set
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# end of LPDDR & LPDDR2 PCM memory drivers
+
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_HYPERBUS is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_DYNAMIC=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_RESERVED_MEM=y
+CONFIG_OF_RESOLVE=y
+CONFIG_OF_OVERLAY=y
+CONFIG_OF_NUMA=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+# end of EEPROM support
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# end of Texas Instruments shared transport line discipline
+
+#
+# Altera FPGA firmware download module (requires I2C)
+#
+
+#
+# Intel MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+# CONFIG_VOP_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# end of Intel MIC & related support
+
+# CONFIG_ECHO is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# end of SCSI device support
+
+CONFIG_HAVE_PATA_PLATFORM=y
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# end of Distributed Switch Architecture drivers
+
+# CONFIG_ETHERNET is not set
+# CONFIG_MDIO_DEVICE is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_NETDEVSIM is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_NULL_TTY is not set
+CONFIG_LDISC_AUTOLOAD=y
+CONFIG_DEVMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_NUA3500=y
+CONFIG_SERIAL_NUA3500_CONSOLE=y
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# end of Serial drivers
+
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_SERIAL_DEV_CTRL_TTYPORT=y
+CONFIG_TTY_PRINTK=y
+CONFIG_TTY_PRINTK_LEVEL=6
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+# end of Character devices
+
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# end of I2C support
+
+# CONFIG_I3C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# end of PTP clock support
+
+CONFIG_PINCTRL=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_OCELOT is not set
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_PL061 is not set
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_XGENE is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# end of Memory mapped GPIO drivers
+
+#
+# MFD GPIO expanders
+#
+# end of MFD GPIO expanders
+
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_BRCMSTB is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_XGENE is not set
+# CONFIG_POWER_RESET_SYSCON is not set
+# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
+CONFIG_REBOOT_MODE=y
+CONFIG_SYSCON_REBOOT_MODE=y
+# CONFIG_NVMEM_REBOOT_MODE is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_LT3651 is not set
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+# CONFIG_THERMAL_STATISTICS is not set
+CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+# CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR=y
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_GOV_STEP_WISE is not set
+# CONFIG_THERMAL_GOV_BANG_BANG is not set
+CONFIG_THERMAL_GOV_USER_SPACE=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+# CONFIG_CLOCK_THERMAL is not set
+CONFIG_DEVFREQ_THERMAL=y
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_THERMAL_MMIO is not set
+# CONFIG_QORIQ_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TQMX86 is not set
+# CONFIG_RAVE_SP_CORE is not set
+# end of Multifunction device drivers
+
+# CONFIG_REGULATOR is not set
+# CONFIG_RC_CORE is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_DRM_DP_CEC is not set
+
+#
+# ARM devices
+#
+# end of ARM devices
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# end of ACP (Audio CoProcessor) Configuration
+
+CONFIG_DRM_RCAR_WRITEBACK=y
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_SIMPLE is not set
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+# CONFIG_LCD_CLASS_DEVICE is not set
+# CONFIG_BACKLIGHT_CLASS_DEVICE is not set
+# end of Backlight & LCD device support
+
+# CONFIG_LOGO is not set
+# end of Graphics support
+
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+# CONFIG_HID is not set
+# end of HID support
+
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+CONFIG_PWRSEQ_EMMC=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_ARMMMCI is not set
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_SDHCI_OF_ARASAN is not set
+# CONFIG_MMC_SDHCI_OF_ASPEED is not set
+# CONFIG_MMC_SDHCI_OF_AT91 is not set
+CONFIG_MMC_SDHCI_OF_DWCMSHC=y
+# CONFIG_MMC_SDHCI_CADENCE is not set
+# CONFIG_MMC_SDHCI_F_SDH30 is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+# CONFIG_MMC_CQHCI is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MMC_SDHCI_XENON is not set
+# CONFIG_MMC_SDHCI_OMAP is not set
+# CONFIG_MMC_SDHCI_AM654 is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# end of DMABUF options
+
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_VIRTIO_MENU is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+# CONFIG_GREYBUS is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+CONFIG_COMMON_CLK_VERSATILE=y
+# CONFIG_CLK_SP810 is not set
+# CONFIG_CLK_HSDK is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_XGENE is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+# end of Common Clock Framework
+
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_ARCH_TIMER_OOL_WORKAROUND=y
+CONFIG_FSL_ERRATUM_A008585=y
+CONFIG_HISILICON_ERRATUM_161010101=y
+CONFIG_ARM64_ERRATUM_858921=y
+# end of Clock Source drivers
+
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+# end of Amlogic SoC drivers
+
+#
+# Aspeed SoC drivers
+#
+# end of Aspeed SoC drivers
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# i.MX SoC drivers
+#
+# end of i.MX SoC drivers
+
+#
+# Qualcomm SoC drivers
+#
+# end of Qualcomm SoC drivers
+
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# end of Xilinx SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+# CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND is not set
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+# CONFIG_DEVFREQ_GOV_PASSIVE is not set
+
+#
+# DEVFREQ Drivers
+#
+CONFIG_PM_DEVFREQ_EVENT=y
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+CONFIG_ARM_GIC_V3=y
+CONFIG_ARM_GIC_V3_ITS=y
+# CONFIG_AL_FIC is not set
+CONFIG_PARTITION_PERCPU=y
+# end of IRQ chip support
+
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_XGENE is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_CADENCE_DP is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+# end of PHY Subsystem
+
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+# CONFIG_ARM_CCI_PMU is not set
+# CONFIG_ARM_CCN is not set
+CONFIG_ARM_PMU=y
+# CONFIG_ARM_DSU_PMU is not set
+# CONFIG_ARM_SPE_PMU is not set
+# end of Performance monitor support
+
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# end of Android
+
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SYSFS=y
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+CONFIG_PM_OPP=y
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_INTERCONNECT is not set
+# CONFIG_COUNTER is not set
+# end of Device Drivers
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_VALIDATE_FS_PARSER is not set
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FS_DAX is not set
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FS_VERITY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# end of Caches
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+# end of CD-ROM/DVD Filesystems
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_NTFS_FS is not set
+# end of DOS/FAT/NT Filesystems
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLBFS is not set
+CONFIG_MEMFD_CREATE=y
+CONFIG_ARCH_HAS_GIGANTIC_PAGE=y
+CONFIG_CONFIGFS_FS=y
+# end of Pseudo filesystems
+
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_EROFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+# CONFIG_UNICODE is not set
+# end of File systems
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_FORTIFY_SOURCE is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# end of Memory initialization
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_KPP=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_CRYPTD=y
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+CONFIG_CRYPTO_SIMD=y
+
+#
+# Public-key cryptography
+#
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_DH is not set
+CONFIG_CRYPTO_ECC=y
+CONFIG_CRYPTO_ECDH=y
+# CONFIG_CRYPTO_ECRDSA is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CFB is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_OFB is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_ADIANTUM is not set
+# CONFIG_CRYPTO_ESSIV is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_XXHASH is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_LIB_SHA256=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_LIB_AES=y
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_HW is not set
+
+#
+# Certificates for signature checking
+#
+# end of Certificates for signature checking
+
+#
+# Library routines
+#
+# CONFIG_PACKING is not set
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_CORDIC is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+# CONFIG_INDIRECT_PIO is not set
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DMA_DECLARE_COHERENT=y
+CONFIG_ARCH_HAS_SETUP_DMA_OPS=y
+CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE=y
+CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU=y
+CONFIG_ARCH_HAS_DMA_PREP_COHERENT=y
+CONFIG_ARCH_HAS_DMA_COHERENT_TO_PFN=y
+CONFIG_SWIOTLB=y
+CONFIG_DMA_REMAP=y
+CONFIG_DMA_DIRECT_REMAP=y
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_SGL_ALLOC=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+CONFIG_HAVE_GENERIC_VDSO=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+# end of Library routines
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+# CONFIG_PRINTK_CALLER is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# end of printk and dmesg options
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_DEBUG_INFO_BTF is not set
+# CONFIG_GDB_SCRIPTS is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_INSTALL is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_MISC=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_ARCH_KASAN=y
+CONFIG_HAVE_ARCH_KASAN_SW_TAGS=y
+CONFIG_CC_HAS_KASAN_GENERIC=y
+# CONFIG_KASAN is not set
+CONFIG_KASAN_STACK=1
+# end of Memory Debugging
+
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_SOFTLOCKUP_DETECTOR=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=10
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_WQ_WATCHDOG=y
+# end of Debug Lockups and Hangs
+
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_PANIC_ON_OOPS_VALUE=1
+CONFIG_PANIC_TIMEOUT=1
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+CONFIG_SCHED_STACK_END_CHECK=y
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_HAVE_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_REED_SOLOMON_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_STRSCPY is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_BITFIELD is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_XARRAY is not set
+# CONFIG_TEST_OVERFLOW is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_VMALLOC is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_BLACKHOLE_DEV is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_KMOD is not set
+# CONFIG_TEST_MEMCAT_P is not set
+# CONFIG_TEST_STACKINIT is not set
+# CONFIG_TEST_MEMINIT is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y
+# CONFIG_UBSAN is not set
+CONFIG_UBSAN_ALIGNMENT=y
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_IO_STRICT_DEVMEM is not set
+# CONFIG_ARM64_PTDUMP_DEBUGFS is not set
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_ARM64_RANDOMIZE_TEXT_OFFSET is not set
+# CONFIG_DEBUG_WX is not set
+# CONFIG_DEBUG_ALIGN_RODATA is not set
+# CONFIG_ARM64_RELOC_TEST is not set
+# CONFIG_CORESIGHT is not set
+# end of Kernel hacking
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 67a9eb3..e84f2a2 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -19,6 +19,21 @@ source "drivers/tty/serial/8250/Kconfig"
 
 comment "Non-8250 serial port support"
 
+config SERIAL_NUA3500
+	bool "NUA3500 serial support"
+	depends on ARCH_NUA3500
+	select SERIAL_CORE
+	help
+	  This selects NUA3500 serial driver.
+
+config SERIAL_NUA3500_CONSOLE
+	bool "Console on NUA3500 serial port"
+	depends on SERIAL_NUA3500
+	select SERIAL_CORE_CONSOLE
+	help
+	  If you say Y here, it will be possible to use a serial port as the
+	  system console.
+
 config SERIAL_AMBA_PL010
 	tristate "ARM AMBA PL010 serial port support"
 	depends on ARM_AMBA
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 863f470..0decf45 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -89,6 +89,7 @@ obj-$(CONFIG_SERIAL_OWL)	+= owl-uart.o
 obj-$(CONFIG_SERIAL_RDA)	+= rda-uart.o
 obj-$(CONFIG_SERIAL_MILBEAUT_USIO) += milbeaut_usio.o
 obj-$(CONFIG_SERIAL_SIFIVE)	+= sifive.o
+obj-$(CONFIG_SERIAL_NUA3500)  += nua3500_serial.o
 
 # GPIOLIB helpers for modem control lines
 obj-$(CONFIG_SERIAL_MCTRL_GPIO)	+= serial_mctrl_gpio.o
diff --git a/drivers/tty/serial/nua3500_serial.c b/drivers/tty/serial/nua3500_serial.c
new file mode 100755
index 0000000..799c00b
--- /dev/null
+++ b/drivers/tty/serial/nua3500_serial.c
@@ -0,0 +1,2167 @@
+/*
+ *  linux/drivers/tty/serial/nua3500_serial.c
+ *
+ *  NUA3500 serial driver
+ *
+ *
+ *  Copyright (C) 2018 Nuvoton Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+ 
+#if defined(CONFIG_SERIAL_NUA3500_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/clk.h>
+#include <linux/serial_reg.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/nmi.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+
+//#include <mach/map.h>
+//#include <mach/regs-serial.h>
+//#include <mach/regs-gcr.h>
+//#include <mach/mfp.h>
+//#include <mach/regs-pdma.h>
+//#include <mach/sram.h>
+//#include <linux/platform_data/dma-nua3500.h>
+
+
+#include "nua3500_serial.h"
+
+u64 uart0_base;
+
+//#define USING_SRAM
+#define UART_NR 1
+#define UART_RX_BUF_SIZE 128 //bytes
+#define UART_TX_MAX_BUF_SIZE 128 //bytes
+
+//#define CONFIG_USE_DDR 1
+
+// PDMA mode time-out
+#define Time_Out_Frame_Count 2
+#define Time_Out_Low_Baudrate 9600
+
+
+static struct uart_driver nua3500serial_reg;
+
+struct clk      *clk;
+
+struct uart_nua3500_port {
+	struct uart_port    port;
+
+	unsigned short      capabilities;   /* port capabilities */
+	unsigned char       ier;
+	unsigned char       lcr;
+	unsigned char       mcr;
+	unsigned char       mcr_mask;  /* mask of user bits */
+	unsigned char       mcr_force; /* mask of forced bits */
+
+	struct serial_rs485 rs485; /* rs485 settings */
+
+#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+	struct nua3500_ip_rx_dma dma_rx;
+	struct nua3500_ip_tx_dma dma_tx;
+	struct nua3500_mem_alloc src_mem_p;
+	struct nua3500_mem_alloc dest_mem_p;
+	struct nua3500_dma_done   dma_slave_done;
+
+	unsigned char PDMA_UARTx_TX;
+	unsigned char PDMA_UARTx_RX;
+
+	struct nua3500_dma_done   dma_Rx_done;
+	struct nua3500_dma_done   dma_Tx_done;
+
+	unsigned int tx_dma_len;
+
+	unsigned char uart_pdma_enable_flag;
+	unsigned char Tx_pdma_busy_flag;
+
+	unsigned int pdma_time_out_prescaler;
+	unsigned int pdma_time_out_count;
+	unsigned int baud_rate;
+#endif
+
+	/*
+	* We provide a per-port pm hook.
+	*/
+	void    (*pm)(struct uart_port *port, unsigned int state, unsigned int old);
+};
+
+static struct uart_nua3500_port nua3500serial_ports[UART_NR]={0};
+
+
+static inline void __stop_tx(struct uart_nua3500_port *p);
+
+#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+static void nua3500_prepare_RX_dma(struct uart_nua3500_port *p);
+static void nua3500_prepare_TX_dma(struct uart_nua3500_port *p);
+#endif
+
+static inline struct uart_nua3500_port *
+to_nua3500_uart_port(struct uart_port *uart)
+{
+	return container_of(uart, struct uart_nua3500_port, port);
+}
+
+static inline unsigned int serial_in(struct uart_nua3500_port *p, int offset)
+{
+	return(__raw_readl(p->port.membase + offset));
+}
+
+static inline void serial_out(struct uart_nua3500_port *p, int offset, int value)
+{
+	__raw_writel(value, p->port.membase + offset);
+}
+
+#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+
+static void nua3500_Rx_dma_callback(void *arg)
+{
+	struct nua3500_dma_done *done = arg;
+	struct uart_nua3500_port *p = (struct uart_nua3500_port *)done->callback_param;
+	struct tty_port    *tty_port = &p->port.state->port;
+	int count;
+	int copied_count = 0;
+
+	if(done->timeout==1)
+		count = ((p->dest_mem_p.size/2) -(done->remain +1));
+	else
+		count = (p->dest_mem_p.size/2);
+
+	spin_lock(&p->port.lock);
+
+	if(done->base_addr==1)
+		copied_count = tty_insert_flip_string(tty_port, (unsigned char *)(p->dest_mem_p.vir_addr), count);
+	else
+		copied_count = tty_insert_flip_string(tty_port, (unsigned char *)(p->dest_mem_p.vir_addr+(p->dest_mem_p.size/2)), count);
+
+	if(copied_count != count) {
+		printk("\n Rx overrun: dropping %u bytes \n", (count - copied_count));
+	}
+
+	p->port.icount.rx +=copied_count;
+
+	tty_flip_buffer_push(tty_port);
+
+	spin_unlock(&p->port.lock);
+
+	if(done->timeout==1) {
+		nua3500_prepare_RX_dma(p);
+		//Trigger Rx dma again
+		serial_out(p, UART_REG_IER, (serial_in(p, UART_REG_IER)|RXPDMAEN));
+	}
+
+	return;
+}
+
+static void nua3500_Tx_dma_callback(void *arg)
+{
+	struct nua3500_dma_done *done = arg;
+	struct uart_nua3500_port *p = (struct uart_nua3500_port *)done->callback_param;
+	struct circ_buf *xmit = &p->port.state->xmit;
+
+	spin_lock(&p->port.lock);
+
+	p->port.icount.tx += p->tx_dma_len;
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&p->port);
+
+	if (!uart_circ_empty(xmit) && !uart_tx_stopped(&p->port)) {
+		p->Tx_pdma_busy_flag = 1;
+		nua3500_prepare_TX_dma(p);
+		// Trigger Tx dma again
+		serial_out(p, UART_REG_IER, (serial_in(p, UART_REG_IER)| TXPDMAEN));
+	} else {
+		p->Tx_pdma_busy_flag = 0;
+	}
+
+	spin_unlock(&p->port.lock);
+}
+
+static void set_pdma_flag(struct uart_nua3500_port *p, int id)
+{
+#if defined(CONFIG_ENABLE_UART1_PDMA) || defined(CONFIG_OF)
+	if(id == 1) {
+		p->uart_pdma_enable_flag = 1;
+		p->PDMA_UARTx_RX = PDMA_UART1_RX;
+		p->PDMA_UARTx_TX = PDMA_UART1_TX;
+	}
+#endif
+
+#if defined(CONFIG_ENABLE_UART2_PDMA) || defined(CONFIG_OF)
+	if(id == 2) {
+		p->uart_pdma_enable_flag = 1;
+		p->PDMA_UARTx_RX = PDMA_UART2_RX;
+		p->PDMA_UARTx_TX = PDMA_UART2_TX;
+	}
+#endif
+
+#if defined(CONFIG_ENABLE_UART3_PDMA) || defined(CONFIG_OF)
+	if(id == 3) {
+		p->uart_pdma_enable_flag = 1;
+		p->PDMA_UARTx_RX = PDMA_UART3_RX;
+		p->PDMA_UARTx_TX = PDMA_UART3_TX;
+	}
+#endif
+
+#if defined(CONFIG_ENABLE_UART4_PDMA) || defined(CONFIG_OF)
+	if(id == 4) {
+		p->uart_pdma_enable_flag = 1;
+		p->PDMA_UARTx_RX = PDMA_UART4_RX;
+		p->PDMA_UARTx_TX = PDMA_UART4_TX;
+	}
+#endif
+
+#if defined(CONFIG_ENABLE_UART5_PDMA) || defined(CONFIG_OF)
+	if(id == 5) {
+		p->uart_pdma_enable_flag = 1;
+		p->PDMA_UARTx_RX = PDMA_UART5_RX;
+		p->PDMA_UARTx_TX = PDMA_UART5_TX;
+	}
+#endif
+
+#if defined(CONFIG_ENABLE_UART6_PDMA) || defined(CONFIG_OF)
+	if(id == 6) {
+		p->uart_pdma_enable_flag = 1;
+		p->PDMA_UARTx_RX = PDMA_UART6_RX;
+		p->PDMA_UARTx_TX = PDMA_UART6_TX;
+	}
+#endif
+
+#if defined(CONFIG_ENABLE_UART7_PDMA) || defined(CONFIG_OF)
+	if(id == 7) {
+		p->uart_pdma_enable_flag = 1;
+		p->PDMA_UARTx_RX = PDMA_UART7_RX;
+		p->PDMA_UARTx_TX = PDMA_UART7_TX;
+	}
+#endif
+
+#if defined(CONFIG_ENABLE_UART8_PDMA) || defined(CONFIG_OF)
+	if(id == 8) {
+		p->uart_pdma_enable_flag = 1;
+		p->PDMA_UARTx_RX = PDMA_UART8_RX;
+		p->PDMA_UARTx_TX = PDMA_UART8_TX;
+	}
+#endif
+
+#if defined(CONFIG_ENABLE_UART9_PDMA) || defined(CONFIG_OF)
+	if(id == 9) {
+		p->uart_pdma_enable_flag = 1;
+		p->PDMA_UARTx_RX = PDMA_UART9_RX;
+		p->PDMA_UARTx_TX = PDMA_UART9_TX;
+	}
+#endif
+}
+
+#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+void nua3500_uart_cal_pdma_time_out(struct uart_nua3500_port *p, unsigned int baud)
+{
+	unsigned int lcr;
+	unsigned int pdma_time_out_base = 300000000 * Time_Out_Frame_Count / 256; // 300M*Time_Out_Frame_Count/256
+	unsigned int time_out_prescaler = 0;
+	unsigned int bit_length;
+	unsigned int time_out;
+
+	if(baud > Time_Out_Low_Baudrate){
+		p->pdma_time_out_count = 255;
+		p->pdma_time_out_prescaler = 7;
+
+		return;
+	}
+
+	bit_length = 2;//1 start + 1 stop bit
+
+	lcr = serial_in(p, UART_REG_LCR);
+	switch(lcr & 0x3){
+		case 0:
+			bit_length += 5;
+
+			break;
+		case 1:
+			bit_length += 6;
+
+			break;
+		case 2:
+			bit_length += 7;
+
+			break;
+		case 3:
+			bit_length += 8;
+
+			break;
+	}
+
+	if(lcr & 0x4)
+		bit_length += 1;
+
+	if(lcr & 0x8)//Parity bit
+		bit_length += 1;
+
+	time_out = pdma_time_out_base * bit_length;
+	time_out = (time_out / baud) + 1;
+
+	while(time_out > 65535) // pdma max. time-out count is 65535
+	{
+		time_out = time_out / 2;
+		time_out_prescaler++;
+	}
+
+	if(time_out == 0) time_out = 1;
+
+	p->pdma_time_out_count = time_out;
+	p->pdma_time_out_prescaler = time_out_prescaler;
+
+	return;
+}
+#endif
+
+static void nua3500_prepare_RX_dma(struct uart_nua3500_port *p)
+{
+	struct nua3500_dma_config dma_crx;
+	struct nua3500_ip_rx_dma *pdma_rx = &(p->dma_rx);
+	dma_cookie_t cookie;
+
+	serial_out(p, UART_REG_IER, (serial_in(p, UART_REG_IER)&~ RXPDMAEN));
+
+	if(p->dest_mem_p.size == 0) {
+		// use DDR
+#ifndef USING_SRAM
+		//p->dest_mem_p.size = 256;
+		p->dest_mem_p.size = 4096*2;
+		p->dest_mem_p.vir_addr = (u64)dma_alloc_writecombine(NULL,
+		                         PAGE_ALIGN(p->dest_mem_p.size),
+		                         (dma_addr_t *)&(p->dest_mem_p.phy_addr),
+		                         GFP_KERNEL);
+#else
+		p->dest_mem_p.size = 256; //set to 256 bytes
+		p->dest_mem_p.vir_addr =(u32)sram_alloc(p->dest_mem_p.size, &(p->dest_mem_p.phy_addr));
+#endif
+	}
+
+	pdma_rx->slave_config.src_addr = (u64)(p->port.membase - 0x40000000);
+	pdma_rx->slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	pdma_rx->slave_config.src_maxburst = 1;
+	pdma_rx->slave_config.direction = DMA_DEV_TO_MEM;
+	pdma_rx->slave_config.device_fc = false;
+	dmaengine_slave_config(pdma_rx->chan_rx,&(pdma_rx->slave_config));
+
+	sg_init_table(pdma_rx->sgrx, 1);
+	pdma_rx->sgrx[0].dma_address = p->dest_mem_p.phy_addr;
+	pdma_rx->sgrx[0].length = p->dest_mem_p.size;
+	dma_crx.reqsel = p->PDMA_UARTx_RX;
+
+	dma_crx.timeout_counter = p->pdma_time_out_count;
+	dma_crx.timeout_prescaler = p->pdma_time_out_prescaler;
+
+	dma_crx.en_sc = 1;
+	pdma_rx->rxdesc=pdma_rx->chan_rx->device->device_prep_slave_sg(pdma_rx->chan_rx,
+	                pdma_rx->sgrx,
+	                1,
+	                DMA_FROM_DEVICE,
+	                DMA_PREP_INTERRUPT | DMA_CTRL_ACK,
+	                (void *)&dma_crx); //PDMA Request Source Select
+	if (!pdma_rx->rxdesc) {
+		printk("pdma->rxdesc=NULL\n");
+		while(1);
+	}
+	//dma_slave_done.done = false;
+	pdma_rx->rxdesc->callback = nua3500_Rx_dma_callback;
+	p->dma_Rx_done.callback_param = p;
+	p->dma_Rx_done.base_addr = 0;
+	p->dma_Rx_done.timeout = 0;
+	pdma_rx->rxdesc->callback_param = &(p->dma_Rx_done);
+	cookie = pdma_rx->rxdesc->tx_submit(pdma_rx->rxdesc);
+	if (dma_submit_error(cookie)) {
+		printk("rx dma_submit_error  \n");
+		while(1);
+	}
+
+}
+
+static void nua3500_prepare_TX_dma(struct uart_nua3500_port *p)
+{
+	struct nua3500_dma_config dma_ctx;
+	struct nua3500_ip_tx_dma *pdma_tx = &(p->dma_tx);
+	dma_cookie_t cookie;
+	struct circ_buf *xmit = &p->port.state->xmit;
+
+	if(p->src_mem_p.size == 0) {
+		p->src_mem_p.size = UART_XMIT_SIZE;
+		p->src_mem_p.vir_addr = (u64)dma_alloc_writecombine(NULL,
+		                        PAGE_ALIGN(p->src_mem_p.size),
+		                        (dma_addr_t *)&(p->src_mem_p.phy_addr),
+		                        GFP_KERNEL);
+	}
+
+	p->tx_dma_len = uart_circ_chars_pending(xmit);
+	if (xmit->tail < xmit->head) {
+		memcpy((unsigned char *)p->src_mem_p.vir_addr, &xmit->buf[xmit->tail], p->tx_dma_len);
+	} else {
+		size_t first = UART_XMIT_SIZE - xmit->tail;
+		size_t second = xmit->head;
+		memcpy((unsigned char *)p->src_mem_p.vir_addr, &xmit->buf[xmit->tail], first);
+		if (second)
+			memcpy((unsigned char *)p->src_mem_p.vir_addr+first, &xmit->buf[0], second);
+	}
+	xmit->tail = (xmit->tail +  p->tx_dma_len) & (UART_XMIT_SIZE - 1);
+
+	serial_out(p, UART_REG_IER, (serial_in(p, UART_REG_IER) &~ TXPDMAEN));
+	pdma_tx->slave_config.dst_addr = (u64)(p->port.membase - 0x40000000);
+	pdma_tx->slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+	pdma_tx->slave_config.dst_maxburst = 1;
+	pdma_tx->slave_config.direction = DMA_MEM_TO_DEV;
+	dmaengine_slave_config(pdma_tx->chan_tx,&(pdma_tx->slave_config));
+	sg_init_table(pdma_tx->sgtx, 1);
+	pdma_tx->sgtx[0].dma_address =p->src_mem_p.phy_addr;
+	pdma_tx->sgtx[0].length = p->tx_dma_len;
+	dma_ctx.reqsel = p->PDMA_UARTx_TX;
+	// disable time-out
+	dma_ctx.timeout_counter = 0;
+	dma_ctx.timeout_prescaler = 0;
+	dma_ctx.en_sc = 0;
+	pdma_tx->txdesc = pdma_tx->chan_tx->device->device_prep_slave_sg(pdma_tx->chan_tx,
+	                  pdma_tx->sgtx,
+	                  1,
+	                  DMA_TO_DEVICE,
+	                  DMA_PREP_INTERRUPT | DMA_CTRL_ACK,
+	                  (void *)&dma_ctx);
+	if (!pdma_tx->txdesc) {
+		printk("pdma->txdes==NULL\n");
+		while(1);
+	}
+
+	pdma_tx->txdesc->callback = nua3500_Tx_dma_callback;
+	p->dma_Tx_done.callback_param = p;
+	pdma_tx->txdesc->callback_param = &(p->dma_Tx_done);
+
+	cookie = pdma_tx->txdesc->tx_submit(pdma_tx->txdesc);
+	if (dma_submit_error(cookie)) {
+		printk("dma_submit_error\n");
+		while(1);
+	}
+}
+
+#endif
+
+
+static void rs485_start_rx(struct uart_nua3500_port *port)
+{
+#if 0  // user can enable to control RTS pin level
+	// when enable this define, user need disable auto-flow control
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+
+	if(port->rs485.flags & SER_RS485_RTS_AFTER_SEND) {
+		// Set logical level for RTS pin equal to high
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) & ~0x200) );
+	} else {
+		// Set logical level for RTS pin equal to low
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) | 0x200) );
+	}
+#endif
+}
+
+static void rs485_stop_rx(struct uart_nua3500_port *port)
+{
+#if 0  // user can enable to control RTS pin level
+	// when enable this define, user need disable auto-flow control
+	if(port->rs485.flags & SER_RS485_RTS_ON_SEND) {
+		// Set logical level for RTS pin equal to high
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) & ~0x200) );
+	} else {
+		// Set logical level for RTS pin equal to low
+		serial_out(port, UART_REG_MCR, (serial_in(port, UART_REG_MCR) | 0x200) );
+	}
+#endif
+
+}
+
+static inline void __stop_tx(struct uart_nua3500_port *p)
+{
+	unsigned int ier;
+	struct tty_struct *tty = p->port.state->port.tty;
+
+	if ((ier = serial_in(p, UART_REG_IER)) & THRE_IEN) {
+		serial_out(p, UART_REG_IER, ier & ~THRE_IEN);
+	}
+	if (p->rs485.flags & SER_RS485_ENABLED)
+		rs485_start_rx(p);
+
+	if (tty->termios.c_line == N_IRDA) {
+		while(!(serial_in(p, UART_REG_FSR) & TX_EMPTY));
+		while(!(serial_in(p, UART_REG_FSR) & TE_FLAG));
+
+		serial_out(p, UART_REG_IRCR, (serial_in(p, UART_REG_IRCR) & ~0x2) ); // Tx disable (select Rx)
+	}
+
+}
+
+static void nua3500serial_stop_tx(struct uart_port *port)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+
+	__stop_tx(up);
+}
+
+static void transmit_chars(struct uart_nua3500_port *up);
+
+static void nua3500serial_start_tx(struct uart_port *port)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+	unsigned int ier;
+	struct tty_struct *tty = up->port.state->port.tty;
+#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+	struct circ_buf *xmit = &up->port.state->xmit;
+#endif
+
+	if (tty->termios.c_line == N_IRDA) {
+		serial_out(up, UART_REG_IRCR, (serial_in(up, UART_REG_IRCR) | 0x2) ); // Tx enable
+	}
+
+	if (up->rs485.flags & SER_RS485_ENABLED)
+		rs485_stop_rx(up);
+
+#if 0   // No use FIFO
+	if (!((ier = serial_in(up, UART_REG_IER)) & THRE_IEN)) {
+		ier |= THRE_IEN;
+		serial_out(up, UART_REG_IER, ier);
+	}
+#else // use FIFO
+#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+	if(up->uart_pdma_enable_flag == 1) {
+		if(up->Tx_pdma_busy_flag == 1) {
+			return;
+		}
+
+		if (uart_circ_empty(xmit)) {
+			__stop_tx(up);
+			return;
+		}
+
+		up->Tx_pdma_busy_flag = 1;
+		nua3500_prepare_TX_dma(up);
+		serial_out(up, UART_REG_IER, (serial_in(up, UART_REG_IER)|TXPDMAEN));
+	} else
+#endif
+	{
+		struct circ_buf *xmit = &up->port.state->xmit;
+		ier = serial_in(up, UART_REG_IER);
+		serial_out(up, UART_REG_IER, ier & ~THRE_IEN);
+		if( uart_circ_chars_pending(xmit)<(16-((serial_in(up, UART_REG_FSR)>>16)&0x3F)) )
+			transmit_chars(up);
+		serial_out(up, UART_REG_IER, ier | THRE_IEN);
+	}
+#endif
+
+}
+
+static void nua3500serial_stop_rx(struct uart_port *port)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+
+	serial_out(up, UART_REG_IER, serial_in(up, UART_REG_IER) & ~RDA_IEN);
+}
+
+static void nua3500serial_enable_ms(struct uart_port *port)
+{
+
+}
+
+static int max_count = 0;
+
+static void
+receive_chars(struct uart_nua3500_port *up)
+{
+	unsigned char ch;
+	unsigned int fsr;
+	unsigned int isr;
+	unsigned int dcnt;
+
+	char flag;
+	isr = serial_in(up, UART_REG_ISR);
+	fsr = serial_in(up, UART_REG_FSR);
+
+	while(!(fsr & RX_EMPTY)) {
+		//fsr = serial_in(up, UART_REG_FSR);
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(fsr & (BIF | FEF | PEF | RX_OVER_IF))) {
+			if (fsr & BIF) {
+				serial_out(up, UART_REG_FSR, BIF);
+				up->port.icount.brk++;
+				if (uart_handle_break(&up->port))
+					continue;
+			}
+
+			if (fsr & FEF) {
+				serial_out(up, UART_REG_FSR, FEF);
+				up->port.icount.frame++;
+			}
+
+			if (fsr & PEF) {
+				serial_out(up, UART_REG_FSR, PEF);
+				up->port.icount.parity++;
+			}
+
+			if (fsr & RX_OVER_IF) {
+				serial_out(up, UART_REG_FSR, RX_OVER_IF);
+				up->port.icount.overrun++;
+			}
+			// FIXME: check port->read_status_mask to determin report flags
+			if (fsr & BIF)
+				flag = TTY_BREAK;
+			if (fsr & PEF)
+				flag = TTY_PARITY;
+			if (fsr & FEF)
+				flag = TTY_FRAME;
+		}
+
+		ch = (unsigned char)serial_in(up, UART_REG_RBR);
+
+		if (uart_handle_sysrq_char(&up->port, ch))
+			continue;
+
+		uart_insert_char(&up->port, fsr, RX_OVER_IF, ch, flag);
+		max_count++;
+		dcnt=(serial_in(up, UART_REG_FSR) >> 8) & 0x3f;
+		if(max_count > 1023)
+		{
+			spin_lock(&up->port.lock);
+			tty_flip_buffer_push(&up->port.state->port);
+			spin_unlock(&up->port.lock);
+			max_count=0;
+			if((isr & TOUT_IF) && (dcnt == 0))
+				goto tout_end;
+		}
+
+		if(isr & RDA_IF) {
+			if(dcnt == 1)
+				return; // have remaining data, don't reset max_count
+		}
+		fsr = serial_in(up, UART_REG_FSR);
+	}
+
+	spin_lock(&up->port.lock);
+	tty_flip_buffer_push(&up->port.state->port);
+	spin_unlock(&up->port.lock);
+tout_end:
+	max_count=0;
+	return;
+}
+
+static void transmit_chars(struct uart_nua3500_port *up)
+{
+	struct circ_buf *xmit = &up->port.state->xmit;
+	//int count = 12;
+	int count = 16 -((serial_in(up, UART_REG_FSR)>>16)&0xF);
+
+	if(serial_in(up, UART_REG_FSR) & TX_FULL){
+		count = 0;
+	}
+
+	if (up->port.x_char) {
+		while(serial_in(up, UART_REG_FSR) & TX_FULL);
+		serial_out(up, UART_REG_THR, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+
+	if (uart_tx_stopped(&up->port)) {
+		nua3500serial_stop_tx(&up->port);
+		return;
+	}
+
+	if (uart_circ_empty(xmit)) {
+		__stop_tx(up);
+		return;
+	}
+
+	while(count > 0){
+		//while(serial_in(up, UART_REG_FSR) & TX_FULL);
+		serial_out(up, UART_REG_THR, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		count--;
+		if (uart_circ_empty(xmit))
+			break;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	if (uart_circ_empty(xmit))
+		__stop_tx(up);
+
+}
+
+static unsigned int check_modem_status(struct uart_nua3500_port *up)
+{
+	unsigned int status = 0;
+
+	if (0) {
+		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
+	}
+
+	return status;
+}
+
+static irqreturn_t nua3500serial_interrupt(int irq, void *dev_id)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)dev_id;
+	unsigned int isr, fsr;
+
+	isr = serial_in(up, UART_REG_ISR);
+	fsr = serial_in(up, UART_REG_FSR);
+//	printk("nua3500serial_interrupt isr=0x%08x, fsr=0x%08x\n",isr,fsr);
+#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+	if(up->uart_pdma_enable_flag == 1) {
+		if(fsr & (BIF | FEF | PEF | RX_OVER_IF | HWBUFE_IF | TX_OVER_IF)) {
+			serial_out(up, UART_REG_FSR, (BIF | FEF | PEF | RX_OVER_IF | TX_OVER_IF));
+		}
+	} else
+#endif
+	{
+		//isr = serial_in(up, UART_REG_ISR);
+
+		if (isr & (RDA_IF | TOUT_IF)){
+//			printk("receive_chars\n");
+			receive_chars(up);
+		}
+
+		check_modem_status(up);
+
+		if (isr & THRE_INT)
+			transmit_chars(up);
+
+		if(fsr & (BIF | FEF | PEF | RX_OVER_IF | TX_OVER_IF)) {
+			serial_out(up, UART_REG_FSR, (BIF | FEF | PEF | RX_OVER_IF | TX_OVER_IF));
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static unsigned int nua3500serial_tx_empty(struct uart_port *port)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+	//unsigned long flags;
+	unsigned int fsr;
+
+	//spin_lock_irqsave(&up->port.lock, flags);
+	fsr = serial_in(up, UART_REG_FSR);
+	//spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return (fsr & (TE_FLAG | TX_EMPTY)) == (TE_FLAG | TX_EMPTY) ? TIOCSER_TEMT : 0;
+}
+
+static unsigned int nua3500serial_get_mctrl(struct uart_port *port)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+	unsigned int status;
+	unsigned int ret = 0;
+
+	status = serial_in(up, UART_REG_MSR);;
+
+	if(!(status & 0x10))
+		ret |= TIOCM_CTS;
+
+	return ret;
+}
+
+static void nua3500serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+	unsigned int mcr = 0;
+	unsigned int ier = 0;
+
+	if (mctrl & TIOCM_RTS) {
+		// set RTS high level trigger
+		mcr = serial_in(up, UART_REG_MCR);
+		mcr |= 0x200;
+		mcr &= ~(0x2);
+	}
+
+	if (up->mcr & UART_MCR_AFE) {
+		// set RTS high level trigger
+		mcr = serial_in(up, UART_REG_MCR);
+		mcr |= 0x200;
+		mcr &= ~(0x2);
+
+		// enable CTS/RTS auto-flow control
+		serial_out(up, UART_REG_IER, (serial_in(up, UART_REG_IER) | (0x3000)));
+
+		// Set hardware flow control
+		up->port.flags |= UPF_HARD_FLOW;
+	} else {
+		// disable CTS/RTS auto-flow control
+		ier = serial_in(up, UART_REG_IER);
+		ier &= ~(0x3000);
+		serial_out(up, UART_REG_IER, ier);
+
+		//un-set hardware flow control
+		up->port.flags &= ~UPF_HARD_FLOW;
+	}
+
+	// set CTS high level trigger
+	serial_out(up, UART_REG_MSR, (serial_in(up, UART_REG_MSR) | (0x100)));
+
+	serial_out(up, UART_REG_MCR, mcr);
+}
+
+static void nua3500serial_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+	unsigned long flags;
+	unsigned int lcr;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	lcr = serial_in(up, UART_REG_LCR);
+	if (break_state != 0)
+		lcr |= BCB; // set break
+	else
+		lcr &= ~BCB;    // clr break
+	serial_out(up, UART_REG_LCR, lcr);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static int nua3500serial_startup(struct uart_port *port)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+	struct tty_struct *tty = port->state->port.tty;
+	int retval;
+//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+//	struct nua3500_ip_rx_dma *pdma_rx = &(up->dma_rx);
+//	struct nua3500_ip_tx_dma *pdma_tx = &(up->dma_tx);
+
+//	dma_cap_mask_t mask;
+//#endif
+
+//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+//	dma_cap_zero(mask);
+//	dma_cap_set(DMA_SLAVE, mask);
+//	dma_cap_set(DMA_PRIVATE, mask);
+
+//	if(up->uart_pdma_enable_flag == 1) {
+//		pdma_rx->chan_rx = dma_request_channel(mask, NULL, NULL);
+//		if (!pdma_rx->chan_rx) {
+//			printk("RX DMA channel request error\n");
+//			return -1;
+//		}
+//		pdma_rx->chan_rx->private=(void *)1;
+
+//		pdma_tx->chan_tx = dma_request_channel(mask, NULL, NULL);
+//		if (!pdma_tx->chan_tx) {
+//			printk("TX DMA channel request error\n");
+//			return -1;
+//		}
+//		pdma_tx->chan_tx->private=(void *)1;
+//	}
+//#endif
+
+	/* Reset FIFO */
+	serial_out(up, UART_REG_FCR, TFR | RFR /* | RX_DIS */);
+
+	/* Clear pending interrupts (not every bit are write 1 clear though...) */
+	serial_out(up, UART_REG_ISR, 0xFFFFFFFF);
+
+	retval = request_irq(port->irq, nua3500serial_interrupt, 0, tty ? tty->name : "nua3500_serial", port);
+
+	if (retval) {
+		printk("request irq failed... %d\n",retval);
+		return retval;
+	}
+
+	/*
+	 * Now, initialize the UART
+	 */
+
+//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+//	serial_out(up, UART_REG_FCR, serial_in(up, UART_REG_FCR) | 0x0); // Trigger level 1 byte
+//#else
+//	serial_out(up, UART_REG_FCR, serial_in(up, UART_REG_FCR) | 0x10); // Trigger level 4 byte
+//#endif
+
+//	serial_out(up, UART_REG_LCR, 0x7); // 8 bit
+//	serial_out(up, UART_REG_TOR, 0x40);
+
+//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+//	if(up->uart_pdma_enable_flag == 1)
+//		serial_out(up, UART_REG_IER, RLS_IEN | BUFERR_IEN);
+//	else
+//#endif
+	serial_out(up, UART_REG_IER, RTO_IEN | RDA_IEN | TIME_OUT_EN | BUFERR_IEN);
+//	serial_out(up, UART_REG_IER, RTO_IEN | RDA_IEN | TIME_OUT_EN);
+
+	//serial_out(up, UART_REG_IER, RTO_IEN | RDA_IEN | TIME_OUT_EN | THRE_IEN);
+
+
+	/* 12MHz reference clock input, 115200 */
+	//serial_out(up, UART_REG_BAUD, 0x30000066);
+
+//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+//	if(up->uart_pdma_enable_flag == 1) {
+//		up->baud_rate = 0;
+//	}
+//#endif
+
+	return 0;
+}
+
+static void nua3500serial_shutdown(struct uart_port *port)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+	struct nua3500_ip_rx_dma *pdma_rx = &(up->dma_rx);
+	struct nua3500_ip_tx_dma *pdma_tx = &(up->dma_tx);
+#endif
+
+#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+	if(up->uart_pdma_enable_flag == 1) {
+		dma_release_channel(pdma_rx->chan_rx);
+		dma_release_channel(pdma_tx->chan_tx);
+
+#ifdef USING_SRAM
+		sram_free((void *)up->dest_mem_p.vir_addr, up->dest_mem_p.size);
+#else
+		if(up->dest_mem_p.size != 0)
+		{
+			dma_free_writecombine(NULL, up->dest_mem_p.size, (void *)up->dest_mem_p.vir_addr, up->dest_mem_p.phy_addr);
+		}
+#endif
+
+		if(up->src_mem_p.size != 0)
+		{
+			dma_free_writecombine(NULL, up->src_mem_p.size, (void *)up->src_mem_p.vir_addr, up->src_mem_p.phy_addr);
+		}
+
+		up->Tx_pdma_busy_flag = 0;
+		up->dest_mem_p.size = 0;
+		up->src_mem_p.size = 0;
+	}
+#endif
+
+	free_irq(port->irq, port);
+
+	/*
+	 * Disable interrupts from this port
+	 */
+	serial_out(up, UART_REG_IER, 0);
+}
+
+static unsigned int nua3500serial_get_divisor(struct uart_port *port, unsigned int baud)
+{
+	unsigned int quot;
+
+	quot = (port->uartclk / baud) - 2;
+
+	return quot;
+}
+
+static void
+nua3500serial_set_termios(struct uart_port *port, struct ktermios *termios, struct ktermios *old)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+	unsigned int lcr = 0;
+	unsigned long flags;
+	unsigned int baud, quot;
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		lcr = 0;
+		break;
+	case CS6:
+		lcr |= 1;
+		break;
+	case CS7:
+		lcr |= 2;
+		break;
+	default:
+	case CS8:
+		lcr |= 3;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		lcr |= NSB;
+	if (termios->c_cflag & PARENB)
+		lcr |= PBE;
+	if (!(termios->c_cflag & PARODD))
+		lcr |= EPE;
+	if (termios->c_cflag & CMSPAR)
+		lcr |= SPE;
+
+	baud = uart_get_baud_rate(port, termios, old, port->uartclk / 0xffff, port->uartclk / 11);
+
+	quot = nua3500serial_get_divisor(port, baud);
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	up->port.read_status_mask = RX_OVER_IF /*| UART_LSR_THRE | UART_LSR_DR*/;
+	if (termios->c_iflag & INPCK)
+		up->port.read_status_mask |= FEF | PEF;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= BIF;
+
+	/*
+	 * Characteres to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		up->port.ignore_status_mask |= FEF | PEF;
+	if (termios->c_iflag & IGNBRK) {
+		up->port.ignore_status_mask |= BIF;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			up->port.ignore_status_mask |= RX_OVER_IF;
+	}
+
+	if (termios->c_cflag & CRTSCTS)
+		up->mcr |= UART_MCR_AFE;
+	else
+		up->mcr &= ~UART_MCR_AFE;
+
+	nua3500serial_set_mctrl(&up->port, up->port.mctrl);
+
+	//serial_out(up, UART_REG_BAUD, quot | 0x30000000);
+		serial_out(up, UART_REG_BAUD,  0x3000000E); //schung
+
+	serial_out(up, UART_REG_LCR, lcr);
+
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+#if 0//defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+	if(up->uart_pdma_enable_flag == 1) {
+		if(up->baud_rate != baud){
+			up->baud_rate = baud;
+
+			nua3500_uart_cal_pdma_time_out(up, baud);
+
+			nua3500_prepare_RX_dma(up);
+
+			nua3500_prepare_TX_dma(up);
+
+			// trigger pdma
+			serial_out(up, UART_REG_IER, (serial_in(up, UART_REG_IER)|RXPDMAEN));
+		}
+	}
+#endif
+}
+
+static void
+nua3500serial_set_ldisc(struct uart_port *port, struct ktermios *termios)
+{
+	struct uart_nua3500_port *uart = (struct uart_nua3500_port *)port;
+	unsigned int baud;
+
+	switch (termios->c_line) {
+	case N_IRDA:
+		#if 0
+		baud = serial_in(uart, UART_REG_BAUD);
+		baud = baud & (0x0000ffff);
+		baud = baud + 2;
+		baud = baud / 16;
+		baud = baud - 2;
+
+		serial_out(uart, UART_REG_BAUD, baud);
+		serial_out(uart, UART_REG_IRCR, (serial_in(uart, UART_REG_IRCR) & ~0x40) );  // Rx inverse
+
+		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) & ~FUN_SEL_Msk) );
+		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) | FUN_SEL_IrDA) );
+		#else
+		serial_out(uart, UART_REG_BAUD, 0x3000000E);
+
+		#endif
+		break;
+	default:
+		serial_out(uart, UART_FUN_SEL, (serial_in(uart, UART_FUN_SEL) & ~FUN_SEL_Msk) );
+	}
+
+}
+
+static void
+nua3500serial_pm(struct uart_port *port, unsigned int state, unsigned int oldstate)
+{
+	struct uart_nua3500_port *p = (struct uart_nua3500_port *)port;
+
+	if (p->pm)
+		p->pm(port, state, oldstate);
+}
+
+static void nua3500serial_release_port(struct uart_port *port)
+{
+	//struct platform_device *pdev = to_platform_device(port->dev);
+	//int size = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	//release_mem_region(port->mapbase, size);
+
+	//iounmap(port->membase);
+	//port->membase = NULL;
+}
+
+static int nua3500serial_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void nua3500serial_config_port(struct uart_port *port, int flags)
+{
+	int ret;
+
+	/*
+	 * Find the region that we can probe for.  This in turn
+	 * tells us whether we can probe for the type of port.
+	 */
+	ret = nua3500serial_request_port(port);
+	if (ret < 0)
+		return;
+	port->type = PORT_NUA3500;
+}
+
+static int nua3500serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	if (ser->type != PORT_UNKNOWN && ser->type != PORT_NUA3500)
+		return -EINVAL;
+	return 0;
+}
+
+static const char *nua3500serial_type(struct uart_port *port)
+{
+	return (port->type == PORT_NUA3500) ? "NUA3500" : NULL;
+}
+
+/* Enable or disable the rs485 support */
+static int nua3500serial_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)
+{
+	struct uart_nua3500_port *p = to_nua3500_uart_port(port);
+
+	p->rs485 = *rs485conf;
+
+	if (p->rs485.delay_rts_before_send >= 1000)
+		p->rs485.delay_rts_before_send = 1000;
+
+	serial_out(p, UART_FUN_SEL, (serial_in(p, UART_FUN_SEL) & ~FUN_SEL_Msk) );
+
+	if(rs485conf->flags & SER_RS485_ENABLED) {
+		serial_out(p, UART_FUN_SEL, (serial_in(p, UART_FUN_SEL) | FUN_SEL_RS485) );
+
+		//rs485_start_rx(p);    // stay in Rx mode
+
+		if(rs485conf->flags & SER_RS485_RTS_ON_SEND) {
+			serial_out(p, UART_REG_MCR, (serial_in(p, UART_REG_MCR) & ~0x200) );
+		} else {
+			serial_out(p, UART_REG_MCR, (serial_in(p, UART_REG_MCR) | 0x200) );
+		}
+
+		// set auto direction mode
+		serial_out(p,UART_REG_ALT_CSR,(serial_in(p, UART_REG_ALT_CSR) | (1 << 10)) );
+	}
+
+	return 0;
+}
+
+static int nua3500serial_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+static struct uart_ops nua3500serial_ops = {
+	.tx_empty    = nua3500serial_tx_empty,
+	.set_mctrl   = nua3500serial_set_mctrl,
+	.get_mctrl   = nua3500serial_get_mctrl,
+	.stop_tx     = nua3500serial_stop_tx,
+	.start_tx    = nua3500serial_start_tx,
+	.stop_rx     = nua3500serial_stop_rx,
+	.enable_ms   = nua3500serial_enable_ms,
+	.break_ctl   = nua3500serial_break_ctl,
+	.startup     = nua3500serial_startup,
+	.shutdown    = nua3500serial_shutdown,
+	.set_termios = nua3500serial_set_termios,
+	.set_ldisc   = nua3500serial_set_ldisc,
+	.pm          = nua3500serial_pm,
+	.type        = nua3500serial_type,
+	.release_port= nua3500serial_release_port,
+	.request_port= nua3500serial_request_port,
+	.config_port = nua3500serial_config_port,
+	.verify_port = nua3500serial_verify_port,
+	.ioctl       = nua3500serial_ioctl,
+};
+
+static void __init nua3500serial_init_ports(void)
+{
+	static int first = 1;
+	int i;
+	unsigned char __iomem * sys_base;
+	/* Enable UART0 clock */
+ 	sys_base = ioremap_nocache(0x40460000, 0x10000);
+	__raw_writel(__raw_readl(sys_base+0x20C) | (1 << 12),sys_base+0x20C);  // Uart CLK @ APBCLK0
+	__raw_writel(__raw_readl(sys_base+0x220) & ~(3 << 16),sys_base+0x220); // Uart CLK from HXT
+	//__raw_writel(2,(void *)REG_UART0_IER);		// Enable TX empty interrupt
+
+	/* UART0 multi-function */
+	__raw_writel( (__raw_readl(sys_base+0xA4) & ~0xff000000) | 0x11000000,sys_base+0xA4);
+
+	// UART0 multi-function  PF11,PF12
+	//__raw_writel((__raw_readl(NUA3500_VA_GCR+0x9C)&0xfff00fff) | 0x11000,(NUA3500_VA_GCR+0x9C));
+	if (!first)
+		return;
+	first = 0;
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_nua3500_port *up = &nua3500serial_ports[i];
+
+		up->port.line = i;
+		spin_lock_init(&up->port.lock);
+
+		up->port.ops = &nua3500serial_ops;
+		up->port.iobase = (long)(0x40700000 + (i*0x10000));
+		up->port.membase = ioremap_nocache(up->port.iobase, 0x10000);
+		uart0_base = up->port.membase;
+		//if (!up->port.membase)
+		//	release_mem_region(up->port.membase, 0x10000);
+		if(i==0)
+		{	
+			printk("up->port.membase=0x%08x\n",up->port.membase);
+			__raw_writel(__raw_readl(up->port.membase+0xc) | 0x07,up->port.membase+0xc);
+			__raw_writel(0x3000000E,up->port.membase+0x24);
+		}
+		up->port.uartclk = 12000000;
+
+	}
+}
+
+#ifdef CONFIG_SERIAL_NUA3500_CONSOLE
+static void nua3500serial_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_nua3500_port *up = (struct uart_nua3500_port *)port;
+
+	while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));
+	serial_out(up, UART_REG_THR, ch);
+}
+
+void nua3500console_write(int ch){
+	struct uart_nua3500_port *up = &nua3500serial_ports[0];
+	if(up->port.membase!=NULL)
+	{
+        	while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));
+       		serial_out(up, UART_REG_THR, ch);
+	}
+
+}
+EXPORT_SYMBOL(nua3500console_write);
+
+/*
+ *  Print a string to the serial port trying not to disturb
+ *  any possible real use of the port...
+ *
+ *  The console_lock must be held when we get here.
+ */
+static void nua3500serial_console_write(struct console *co, const char *s, unsigned int count)
+{
+#if 1
+	struct uart_nua3500_port *up = &nua3500serial_ports[co->index];
+	unsigned long flags;
+	unsigned int ier;
+
+	local_irq_save(flags);
+
+	/*
+	 *  First save the IER then disable the interrupts
+	 */
+	ier = serial_in(up, UART_REG_IER);
+	serial_out(up, UART_REG_IER, 0);
+
+	uart_console_write(&up->port, s, count, nua3500serial_console_putchar);
+
+	/*
+	 *  Finally, wait for transmitter to become empty
+	 *  and restore the IER
+	 */
+	while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));
+	serial_out(up, UART_REG_IER, ier);
+
+	local_irq_restore(flags);
+#else
+	int i = count;
+	char *ptr = s;
+	struct uart_nua3500_port *up = &nua3500serial_ports[0];
+	while(i--)
+	{
+		while(!(serial_in(up, UART_REG_FSR) & TX_EMPTY));  //waits for TX_FULL bit is clear
+		serial_out(up, UART_REG_THR, *ptr);
+		if(*ptr == '\n')
+		{
+			while ((serial_in(up,UART_REG_FSR) &TX_EMPTY));
+			serial_out(up,UART_REG_THR, '\r');
+		}
+
+		ptr++;
+	}
+#endif
+}
+
+static int __init nua3500serial_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (co->index >= UART_NR)
+		co->index = 0;
+	port = &nua3500serial_ports[co->index].port;
+
+	if (!port->iobase && !port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+
+static struct console nua3500serial_console = {
+	.name    = "ttyS",
+	.write   = nua3500serial_console_write,
+	.device  = uart_console_device,
+	.setup   = nua3500serial_console_setup,
+	.flags   = CON_PRINTBUFFER | CON_ENABLED,
+	.index   = -1,
+	.data    = &nua3500serial_reg,
+};
+
+static int __init nua3500serial_console_init(void)
+{
+	nua3500serial_init_ports();
+	register_console(&nua3500serial_console);
+
+	return 0;
+}
+console_initcall(nua3500serial_console_init);
+
+#define NUA3500SERIAL_CONSOLE    &nua3500serial_console
+#else
+#define NUA3500SERIAL_CONSOLE    NULL
+#endif
+
+static struct uart_driver nua3500serial_reg = {
+	.owner        = THIS_MODULE,
+	.driver_name  = "serial",
+	.dev_name     = "ttyS",
+	.major        = TTY_MAJOR,
+	.minor        = 64,
+	.cons         = NUA3500SERIAL_CONSOLE,
+	.nr           = UART_NR,
+};
+
+
+/**
+ *
+ *  Suspend one serial port.
+ */
+void nua3500serial_suspend_port(int line)
+{
+	uart_suspend_port(&nua3500serial_reg, &nua3500serial_ports[line].port);
+}
+
+/**
+ *
+ *  Resume one serial port.
+ */
+void nua3500serial_resume_port(int line)
+{
+	struct uart_nua3500_port *up = &nua3500serial_ports[line];
+
+	uart_resume_port(&nua3500serial_reg, &up->port);
+}
+
+#ifndef CONFIG_OF
+static int nua3500serial_pinctrl(struct platform_device *pdev)
+{
+	struct pinctrl *p = NULL;
+	int retval = 0;
+
+	if(pdev->id == 1) {
+#if defined (CONFIG_NUA3500_UART1_PA)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart1-PA");
+#elif defined (CONFIG_NUA3500_UART1_PC)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart1-PC");
+#elif defined (CONFIG_NUA3500_UART1_PF)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart1-PF");
+#elif defined (CONFIG_NUA3500_UART1_FC_PC)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart1-fc-PC");
+#elif defined (CONFIG_NUA3500_UART1_FC_PF)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart1-fc-PF");
+#endif
+
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "unable to reserve pin\n");
+			retval = PTR_ERR(p);
+		}
+	} else if(pdev->id == 2) {
+#if defined (CONFIG_NUA3500_UART2_PA)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart2-PA");
+#elif defined (CONFIG_NUA3500_UART2_PG)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart2-PG");
+#elif defined (CONFIG_NUA3500_UART2_PD)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart2-PD");
+#elif defined (CONFIG_NUA3500_UART2_FC_PA)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart2-fc-PA");
+#elif defined (CONFIG_NUA3500_UART2_FC_PG)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart2-fc-PG");
+#elif defined (CONFIG_NUA3500_UART2_FC_PA_PB)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart2-fc-PA_PB");
+#endif
+
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "unable to reserve pin\n");
+			retval = PTR_ERR(p);
+		}
+	} else if(pdev->id == 3) {
+#if defined (CONFIG_NUA3500_UART3_PC)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart3-PC");
+#elif defined (CONFIG_NUA3500_UART3_PB)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart3-PB");
+#elif defined (CONFIG_NUA3500_UART3_PD)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart3-PD");
+#elif defined (CONFIG_NUA3500_UART3_PB_PF)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart3-PB_PF");
+#elif defined (CONFIG_NUA3500_UART3_PF)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart3-PF");
+#elif defined (CONFIG_NUA3500_UART3_FC_PB)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart3-fc-PB");
+#elif defined (CONFIG_NUA3500_UART3_FC_PD)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart3-fc-PD");
+#elif defined (CONFIG_NUA3500_UART3_FC_PF)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart3-fc-PF");
+#endif
+
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "unable to reserve pin\n");
+			retval = PTR_ERR(p);
+		}
+	} else if(pdev->id == 4) {
+#if defined (CONFIG_NUA3500_UART4_PC)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart4-PC");
+#elif defined (CONFIG_NUA3500_UART4_PD)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart4-PD");
+#elif defined (CONFIG_NUA3500_UART4_PE)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart4-PE");
+#elif defined (CONFIG_NUA3500_UART4_FC_PD)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart4-fc-PD");
+#elif defined (CONFIG_NUA3500_UART4_FC_PE)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart4-fc-PE");
+#endif
+
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "unable to reserve pin\n");
+			retval = PTR_ERR(p);
+		}
+	} else if(pdev->id == 5) {
+#if defined (CONFIG_NUA3500_UART5_PG_0)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart5-PG_0");
+#elif defined (CONFIG_NUA3500_UART5_PD)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart5-PD");
+#elif defined (CONFIG_NUA3500_UART5_PG_1)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart5-PG_1");
+#elif defined (CONFIG_NUA3500_UART5_FC_PG_0)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart5-fc-PG_0");
+#elif defined (CONFIG_NUA3500_UART5_FC_PG_1)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart5-fc-PG_1");
+#endif
+
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "unable to reserve pin\n");
+			retval = PTR_ERR(p);
+		}
+	} else if(pdev->id == 6) {
+#if defined (CONFIG_NUA3500_UART6_PA)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart6-PA");
+#elif defined (CONFIG_NUA3500_UART6_PD)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart6-PD");
+#elif defined (CONFIG_NUA3500_UART6_PE)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart6-PE");
+#elif defined (CONFIG_NUA3500_UART6_FC_PA)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart6-fc-PA");
+#elif defined (CONFIG_NUA3500_UART6_FC_PD)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart6-fc-PD");
+#endif
+
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "unable to reserve pin\n");
+			retval = PTR_ERR(p);
+		}
+	} else if(pdev->id == 7) {
+#if defined (CONFIG_NUA3500_UART7_PA)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart7-PA");
+#elif defined (CONFIG_NUA3500_UART7_PB)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart7-PB");
+#elif defined (CONFIG_NUA3500_UART7_PC)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart7-PC");
+#elif defined (CONFIG_NUA3500_UART7_PF)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart7-PF");
+#elif defined (CONFIG_NUA3500_UART7_FC_PB)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart7-fc-PB");
+#elif defined (CONFIG_NUA3500_UART7_FC_PF)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart7-fc-PF");
+#endif
+
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "unable to reserve pin\n");
+			retval = PTR_ERR(p);
+		}
+	} else if(pdev->id == 8) {
+#if defined (CONFIG_NUA3500_UART8_PA)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart8-PA");
+#elif defined (CONFIG_NUA3500_UART8_PB)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart8-PB");
+#elif defined (CONFIG_NUA3500_UART8_PC)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart8-PC");
+#elif defined (CONFIG_NUA3500_UART8_FC_PA_PG)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart8-fc-PA_PG");
+#elif defined (CONFIG_NUA3500_UART8_FC_PC)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart8-fc-PC");
+#endif
+
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "unable to reserve pin\n");
+			retval = PTR_ERR(p);
+		}
+	} else if(pdev->id == 9) {
+#if defined (CONFIG_NUA3500_UART9_PB)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart9-PB");
+#elif defined (CONFIG_NUA3500_UART9_PE_0)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart9-PE_0");
+#elif defined (CONFIG_NUA3500_UART9_PE_1)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart9-PE_1");
+#elif defined (CONFIG_NUA3500_UART9_FC_PE)
+		p = devm_pinctrl_get_select(&pdev->dev, "uart9-fc-PE");
+#endif
+
+		if (IS_ERR(p)) {
+			dev_err(&pdev->dev, "unable to reserve pin\n");
+			retval = PTR_ERR(p);
+		}
+	}
+
+	return retval;
+}
+#endif
+
+void nua3500serial_set_clock(struct uart_nua3500_port *up)
+{
+#if 1 //schung todo
+#else
+	struct clk *clkmux;
+	struct clk *upll_clk;
+
+	if(up->port.line == 0) {
+		clk = clk_get(NULL, "uart0");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "uart0_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+	}
+
+#ifdef CONFIG_NUA3500_UART1
+	if(up->port.line == 1) {
+		clk = clk_get(NULL, "uart1");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "uart1_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clkmux = clk_get(NULL, "uart1_eclk_mux");
+		upll_clk = clk_get(NULL, "upll");
+		clk_set_parent(clkmux, upll_clk);
+
+		clk = clk_get(NULL, "uart1_eclk_div");
+
+		//clk_set_rate(clk, 100000000);
+		clk_set_rate(clk, 150000000);
+		up->port.uartclk = clk_get_rate(clk);
+	}
+#endif
+
+#ifdef CONFIG_NUA3500_UART2
+	if(up->port.line == 2) {
+		clk = clk_get(NULL, "uart2");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "uart2_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clkmux = clk_get(NULL, "uart2_eclk_mux");
+		upll_clk = clk_get(NULL, "upll");
+		clk_set_parent(clkmux, upll_clk);
+
+		clk = clk_get(NULL, "uart2_eclk_div");
+
+		//clk_set_rate(clk, 100000000);
+		clk_set_rate(clk, 150000000);
+		up->port.uartclk = clk_get_rate(clk);
+	}
+#endif
+
+#ifdef CONFIG_NUA3500_UART3
+	if(up->port.line == 3) {
+		clk = clk_get(NULL, "uart3");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "uart3_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clkmux = clk_get(NULL, "uart3_eclk_mux");
+		upll_clk = clk_get(NULL, "upll");
+		clk_set_parent(clkmux, upll_clk);
+
+		clk = clk_get(NULL, "uart3_eclk_div");
+
+		//clk_set_rate(clk, 100000000);
+		clk_set_rate(clk, 150000000);
+		up->port.uartclk = clk_get_rate(clk);
+	}
+#endif
+
+#ifdef CONFIG_NUA3500_UART4
+	if(up->port.line == 4) {
+		clk = clk_get(NULL, "uart4");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "uart4_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clkmux = clk_get(NULL, "uart4_eclk_mux");
+		upll_clk = clk_get(NULL, "upll");
+		clk_set_parent(clkmux, upll_clk);
+
+		clk = clk_get(NULL, "uart4_eclk_div");
+
+		//clk_set_rate(clk, 100000000);
+		clk_set_rate(clk, 150000000);
+		up->port.uartclk = clk_get_rate(clk);
+	}
+#endif
+
+#ifdef CONFIG_NUA3500_UART5
+	if(up->port.line == 5) {
+		clk = clk_get(NULL, "uart5");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "uart5_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clkmux = clk_get(NULL, "uart5_eclk_mux");
+		upll_clk = clk_get(NULL, "upll");
+		clk_set_parent(clkmux, upll_clk);
+
+		clk = clk_get(NULL, "uart5_eclk_div");
+
+		//clk_set_rate(clk, 100000000);
+		clk_set_rate(clk, 150000000);
+		up->port.uartclk = clk_get_rate(clk);
+	}
+#endif
+
+#ifdef CONFIG_NUA3500_UART6
+	if(up->port.line == 6) {
+		clk = clk_get(NULL, "uart6");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "uart6_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clkmux = clk_get(NULL, "uart6_eclk_mux");
+		upll_clk = clk_get(NULL, "upll");
+		clk_set_parent(clkmux, upll_clk);
+
+		clk = clk_get(NULL, "uart6_eclk_div");
+
+		//clk_set_rate(clk, 100000000);
+		clk_set_rate(clk, 150000000);
+		up->port.uartclk = clk_get_rate(clk);
+	}
+#endif
+
+#ifdef CONFIG_NUA3500_UART7
+	if(up->port.line == 7) {
+		clk = clk_get(NULL, "uart7");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "uart7_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clkmux = clk_get(NULL, "uart7_eclk_mux");
+		upll_clk = clk_get(NULL, "upll");
+		clk_set_parent(clkmux, upll_clk);
+
+		clk = clk_get(NULL, "uart7_eclk_div");
+
+		//clk_set_rate(clk, 100000000);
+		clk_set_rate(clk, 150000000);
+		up->port.uartclk = clk_get_rate(clk);
+	}
+#endif
+
+#ifdef CONFIG_NUA3500_UART8
+	if(up->port.line == 8) {
+		clk = clk_get(NULL, "uart8");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "uart8_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clkmux = clk_get(NULL, "uart8_eclk_mux");
+		upll_clk = clk_get(NULL, "upll");
+		clk_set_parent(clkmux, upll_clk);
+
+		clk = clk_get(NULL, "uart8_eclk_div");
+
+		//clk_set_rate(clk, 100000000);
+		clk_set_rate(clk, 150000000);
+		up->port.uartclk = clk_get_rate(clk);
+	}
+#endif
+
+#ifdef CONFIG_NUA3500_UART9
+	if(up->port.line == 9) {
+		clk = clk_get(NULL, "uart9");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clk = clk_get(NULL, "uart9_eclk");
+		clk_prepare(clk);
+		clk_enable(clk);
+
+		clkmux = clk_get(NULL, "uart9_eclk_mux");
+		upll_clk = clk_get(NULL, "upll");
+		clk_set_parent(clkmux, upll_clk);
+
+		clk = clk_get(NULL, "uart9_eclk_div");
+
+		//clk_set_rate(clk, 100000000);
+		clk_set_rate(clk, 150000000);
+		up->port.uartclk = clk_get_rate(clk);
+	}
+#endif
+#endif
+}
+
+#if defined(CONFIG_OF)
+static int  get_uart_port_number(struct platform_device *pdev)
+{
+	u32   val32[2];
+
+	if (of_property_read_u32_array(pdev->dev.of_node, "port-number", val32, 1) != 0) {
+		printk("%s - can not get port-number!\n", __func__);
+		return -EINVAL;
+	}
+
+	return val32[0];
+}
+#endif
+
+/*
+ * Register a set of serial devices attached to a platform device.  The
+ * list is terminated with a zero flags entry, which means we expect
+ * all entries to have at least UPF_BOOT_AUTOCONF set.
+ */
+ //#define SCHUNG_T
+static int nua3500serial_probe(struct platform_device *pdev)
+{
+	int ip_irq;
+#ifdef SCHUNG_T
+	struct resource *resource;
+#else
+	struct resource *regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	//struct resource *irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+
+#endif
+	int virt_irq,phys_irq;
+	unsigned char * __iomem ip_base;
+	struct uart_nua3500_port *up;
+	struct device_node *np = pdev->dev.of_node;
+//	struct device_node *np;
+	int ret, i;
+
+//	np = of_find_compatible_node(NULL, NULL,
+//							 "nuvoton,nua3500-uart");
+
+	
+//	virt_irq = irq_of_parse_and_map(np,
+//						   0);
+//	phys_irq = irq_of_parse_and_map(np,
+//						   1);
+//	printk("=====>  virt_irq=%d,phys_irq=%d  <=====\n");
+
+	//ip_base = of_iomap(np, 0);
+	//printk("ip_base=0x%08x\n",(u32)ip_base);
+	//ip_irq =irq_of_parse_and_map(np,0);
+	//printk("ip_irq=%d\n",ip_irq);
+	//of_node_put(np);
+//#if defined(CONFIG_OF)
+//	struct pinctrl *pinctrl;
+//	u32   val32[2];
+//#else
+//	int retval;
+//	struct plat_nua3500serial_port *p = pdev->dev.platform_data;
+//#endif
+
+//#if defined(CONFIG_OF)
+//	#if 0 //schung todo
+//	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+//	if (IS_ERR(pinctrl)) {
+//		return PTR_ERR(pinctrl);
+//	}
+//	#endif
+//#else
+//	retval = nua3500serial_pinctrl(pdev);
+//	if(retval != 0)
+//		return retval;
+//#endif
+
+//#if defined(CONFIG_OF)
+//	i = get_uart_port_number(pdev);
+//	if (i < 0)
+//		return -EINVAL;
+//#else
+//	i = pdev->id;
+//#endif
+	i = 0;
+	up = &nua3500serial_ports[i];
+
+	up->port.line = i;
+
+//	nua3500serial_set_clock(up);
+
+//#if defined(CONFIG_ENABLE_UART_PDMA) || defined(CONFIG_OF)
+//#if defined(CONFIG_OF)
+//	if (of_property_read_u32_array(pdev->dev.of_node, "pdma-enable", val32, 1) != 0) {
+//		printk("%s - can not get map-addr!\n", __func__);
+//		return -EINVAL;
+//	}
+//
+//	if(val32[0] == 1) set_pdma_flag(up, i);
+//
+//#else
+//	set_pdma_flag(up, i);
+//#endif
+//#endif
+
+//#if defined(CONFIG_OF)
+	/*--------------------------------------------------------------*/
+	/*  get UART register map address from DTB                      */
+	/*--------------------------------------------------------------*/
+//	if (of_property_read_u32_array(pdev->dev.of_node, "map-addr", val32, 1) != 0) {
+//		printk("%s - can not get map-addr!\n", __func__);
+//		return -EINVAL;
+//	}
+
+//	up->port.membase = (unsigned char __iomem *)val32[0];
+
+//	up->port.iobase         = (unsigned long)up->port.membase;
+
+	//up->port.iobase = pdev->hpa.start + (i * 0x10000);
+#ifdef SCHUNG_T
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	up->port.membase =  resource->start;
+	printk("up->port.membase=0x%08x\n",(u32)up->port.membase);
+	up->port.irq            = platform_get_irq(pdev, 0); // ip_irq;//91;
+	printk("up->port.irq=0x%08x\n",(u32)up->port.irq);
+#else
+	//if (!regs || !irq) {
+	//	printk("ERROR\n");
+	//	dev_err(&pdev->dev, "no registers/irq defined\n");
+	//	return -EINVAL;
+	//}
+	//printk("devm_ioremap  regs->start=0x%08x\n", regs->start);
+//up->port.membase = devm_ioremap_nocache(&pdev->dev, regs->start, resource_size(regs));	
+	//up->port.membase = ioremap_nocache(regs->start, 0x10000);
+//printk("up->port.membase=0x%08x\n",(u32)up->port.membase);
+	//up->port.irq =irq->start;
+	up->port.irq=platform_get_irq(pdev, 0);
+	printk("up->port.irq=0x%08x\n",(u32)up->port.irq);
+
+//		up->port.irq=platform_get_irq(pdev, 1);
+//	printk("up->port.irq=0x%08x  <<<2\n",(u32)up->port.irq);
+//	printk("up->port.irq2=0x%08x\n",(u32)up->port.irq);
+
+//printk("2up->port.membase=0x%08x\n",(u32)devm_ioremap_nocache(&pdev->dev, regs->start, resource_size(regs)));
+//printk("2up->port.irq=0x%08x\n",(u32)platform_get_irq(pdev, 0));
+
+#endif
+	up->port.dev            = &pdev->dev;
+	up->port.flags          = ASYNC_BOOT_AUTOCONF;
+
+	//ret = request_irq(91, nua3500serial_interrupt, 0, "nua3500_serial", up);
+
+	//if (ret) {
+	//	printk("request irq failed... %d\n",ret);
+		//return retval;
+	//}
+
+//#else
+//	up->port.membase        = p->membase;
+
+//	up->port.iobase         = p->iobase;
+//	up->port.irq            = p->irq;
+	//up->port.uartclk        = p->uartclk;
+//	up->port.mapbase        = p->mapbase;
+//	up->port.private_data   = p->private_data;
+//	up->port.dev            = &pdev->dev;
+//	up->port.flags          = ASYNC_BOOT_AUTOCONF;
+
+	/* Possibly override default I/O functions.  */
+//	if (p->serial_in)
+//		up->port.serial_in = p->serial_in;
+//	if (p->serial_out)
+//		up->port.serial_out = p->serial_out;
+
+//#endif
+
+	up->port.rs485_config = nua3500serial_config_rs485;
+
+	ret = uart_add_one_port(&nua3500serial_reg, &up->port);
+	return 0;
+}
+
+/*
+ * Remove serial ports registered against a platform device.
+ */
+static int nua3500serial_remove(struct platform_device *dev)
+{
+	int i;
+	struct uart_port *port = platform_get_drvdata(dev);
+
+	free_irq(port->irq, port);
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_nua3500_port *up = &nua3500serial_ports[i];
+
+		if (up->port.dev == &dev->dev)
+			uart_remove_one_port(&nua3500serial_reg, &up->port);
+	}
+	return 0;
+}
+
+static int nua3500serial_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int i;
+	int wakeup_flag = 0;
+
+	struct uart_nua3500_port *up;
+
+#if defined(CONFIG_OF)
+	i = get_uart_port_number(dev);
+	if (i < 0)
+		return i;
+#else
+	i = dev->id;
+#endif
+
+	up = &nua3500serial_ports[i];
+
+#ifdef CONFIG_ENABLE_UART1_CTS_WAKEUP
+	if(i == 1) {
+		__raw_writel((1<<17) | __raw_readl(REG_WKUPSER0),REG_WKUPSER0);
+		wakeup_flag = 1;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_UART2_CTS_WAKEUP
+	if(i == 2) {
+		__raw_writel((1<<18) | __raw_readl(REG_WKUPSER0),REG_WKUPSER0);
+		wakeup_flag = 1;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_UART3_CTS_WAKEUP
+	if(i == 3) {
+		__raw_writel((1<<19) | __raw_readl(REG_WKUPSER0),REG_WKUPSER0);
+		wakeup_flag = 1;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_UART4_CTS_WAKEUP
+	if(i == 4) {
+		__raw_writel((1<<20) | __raw_readl(REG_WKUPSER0),REG_WKUPSER0);
+		wakeup_flag = 1;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_UART5_CTS_WAKEUP
+	if(i == 5) {
+		__raw_writel((1<<21) | __raw_readl(REG_WKUPSER0),REG_WKUPSER0);
+		wakeup_flag = 1;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_UART6_CTS_WAKEUP
+	if(i == 6) {
+		__raw_writel((1<<22) | __raw_readl(REG_WKUPSER0),REG_WKUPSER0);
+		wakeup_flag = 1;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_UART7_CTS_WAKEUP
+	if(i == 7) {
+		__raw_writel((1<<23) | __raw_readl(REG_WKUPSER0),REG_WKUPSER0);
+		wakeup_flag = 1;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_UART8_CTS_WAKEUP
+	if(i == 8)
+		__raw_writel((1<<24) | __raw_readl(REG_WKUPSER0),REG_WKUPSER0);
+	wakeup_flag = 1;
+#endif
+
+#ifdef CONFIG_ENABLE_UART9_CTS_WAKEUP
+	if(i == 9) {
+		__raw_writel((1<<25) | __raw_readl(REG_WKUPSER0),REG_WKUPSER0);
+		wakeup_flag = 1;
+	}
+#endif
+
+	if(wakeup_flag == 1) {
+		serial_out(up, UART_REG_IER, serial_in(up, UART_REG_IER) | (0x1 << 6));
+		serial_out(up, UART_REG_WKSTS, 0x1); // Clear CTS Wakeup status
+		serial_out(up, UART_REG_WKCTL, 0x1); // Enable CTS Wakeup
+
+		enable_irq_wake(up->port.irq);
+	}
+
+	return 0;
+}
+
+static int nua3500serial_resume(struct platform_device *dev)
+{
+	int i;
+
+	for (i = 0; i < UART_NR; i++) {
+		struct uart_nua3500_port *up = &nua3500serial_ports[i];
+
+		serial_out(up, UART_REG_WKSTS, 0x1); // Clear CTS Wakeup status
+	}
+
+	return 0;
+}
+
+static const struct of_device_id nua3500_serial_of_match[] = {
+	{ .compatible = "nuvoton,nua3500-uart" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, nua3500_serial_of_match);
+
+static struct platform_driver nua3500serial_driver = {
+	.probe      = nua3500serial_probe,
+	.remove     = nua3500serial_remove,
+	.suspend    = nua3500serial_suspend,
+	.resume     = nua3500serial_resume,
+	.driver     =
+	{
+		.name   = "nua3500-uart",
+		.owner  = THIS_MODULE,
+#if defined(CONFIG_OF)
+		.of_match_table = of_match_ptr(nua3500_serial_of_match),
+#endif
+	},
+};
+
+static int __init nua3500serial_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&nua3500serial_reg);
+	if (ret)
+		return ret;
+#ifndef CONFIG_SERIAL_NUA3500_CONSOLE
+	nua3500serial_init_ports();
+#endif
+	ret = platform_driver_register(&nua3500serial_driver);
+	if (ret)
+		uart_unregister_driver(&nua3500serial_reg);
+
+	return ret;
+}
+
+static void __exit nua3500serial_exit(void)
+{
+	platform_driver_unregister(&nua3500serial_driver);
+	uart_unregister_driver(&nua3500serial_reg);
+}
+
+module_init(nua3500serial_init);
+module_exit(nua3500serial_exit);
+
+EXPORT_SYMBOL(nua3500serial_suspend_port);
+EXPORT_SYMBOL(nua3500serial_resume_port);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NUA3500 serial driver");
+
+MODULE_ALIAS_CHARDEV_MAJOR(TTY_MAJOR);
diff --git a/drivers/tty/serial/nua3500_serial.h b/drivers/tty/serial/nua3500_serial.h
new file mode 100755
index 0000000..b851926
--- /dev/null
+++ b/drivers/tty/serial/nua3500_serial.h
@@ -0,0 +1,85 @@
+/*
+ *  linux/drivers/serial/nua3500_serial.h
+ *
+ *  NUA3500 serial driver header file
+ *
+ *
+ *  Copyright (C) 2017 Nuvoton Technology Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __NUA3500_SERIAL_H__
+#define __NUA3500_SERIAL_H__
+
+//#define NUA3500_VA_UART0 0x10000000
+
+#define UART_REG_RBR	0x00
+#define UART_REG_THR	0x00
+
+#define UART_REG_IER	0x04
+#define RDA_IEN		0x00000001
+#define THRE_IEN	0x00000002
+#define RLS_IEN		0x00000004
+#define RTO_IEN		0x00000010
+#define BUFERR_IEN	0x00000020
+#define TIME_OUT_EN	0x00000800
+#define TXPDMAEN	0x00004000
+#define RXPDMAEN	0x00008000
+
+#define UART_REG_FCR	0x08
+#define RFR		0x00000002
+#define TFR		0x00000004
+
+#define UART_REG_LCR	0x0C
+#define	NSB		0x00000004
+#define PBE		0x00000008
+#define EPE		0x00000010
+#define SPE		0x00000020
+#define BCB		0x00000040
+
+#define UART_REG_MCR	0x10
+#define UART_REG_MSR	0x14
+
+#define UART_REG_FSR	0x18
+#define RX_OVER_IF	0x00000001
+#define TX_OVER_IF	0x01000000
+#define PEF		0x00000010
+#define FEF		0x00000020
+#define BIF		0x00000040
+#define RX_EMPTY	0x00004000
+#define TX_EMPTY	0x00400000
+#define TX_FULL		0x00800000
+#define RX_FULL		0x00008000
+#define TE_FLAG		0x10000000
+
+#define UART_REG_ISR	0x1C
+#define RDA_IF		0x00000001
+#define THRE_IF		0x00000002
+#define TOUT_IF		0x00000010
+#define THRE_INT	0x00000200
+#define HWRLS_IF	0x00040000
+#define HWBUFE_IF	0x00200000
+
+#define UART_REG_TOR	0x20
+#define UART_REG_BAUD	0x24
+
+#define UART_REG_IRCR	0x28
+
+#define UART_REG_ALT_CSR	0x2C
+
+#define UART_FUN_SEL	0x30
+#define FUN_SEL_UART	0x00000000
+#define FUN_SEL_LIN		0x00000001
+#define FUN_SEL_IrDA	0x00000002
+#define FUN_SEL_RS485	0x00000003
+#define FUN_SEL_Msk		0x00000007
+
+#define UART_REG_WKCTL	0x40
+#define UART_REG_WKSTS	0x44
+
+#endif // __NUA3500_SERIAL_H__
diff --git a/include/uapi/linux/serial_core.h b/include/uapi/linux/serial_core.h
index e7fe550..05cd717 100644
--- a/include/uapi/linux/serial_core.h
+++ b/include/uapi/linux/serial_core.h
@@ -293,4 +293,7 @@
 /* Freescale Linflex UART */
 #define PORT_LINFLEXUART	122
 
+/* NUA3500 UART */
+#define PORT_NUA3500	123
+
 #endif /* _UAPILINUX_SERIAL_CORE_H */
-- 
2.0.3

