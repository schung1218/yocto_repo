From d9d001dbdf819599646985d66f6e01496f0f6aa0 Mon Sep 17 00:00:00 2001
From: mjchen <mjchen@nuvoton.com>
Date: Mon, 3 Aug 2020 13:12:34 +0800
Subject: [PATCH 7/7] add KPI driver and update dtsi for UART/RTC/KPI

Change-Id: I8bb414cef1afb2adf9f7cc42000c270cc7f0871d
---
 arch/arm64/boot/dts/nuvoton/nua3500.dtsi |  79 ++++++-
 arch/arm64/configs/nua3500_defconfig     |  18 +-
 drivers/input/keyboard/Kconfig           |  10 +
 drivers/input/keyboard/Makefile          |   1 +
 drivers/input/keyboard/nua3500_keypad.c  | 366 +++++++++++++++++++++++++++++++
 5 files changed, 465 insertions(+), 9 deletions(-)
 mode change 100755 => 100644 arch/arm64/configs/nua3500_defconfig
 create mode 100644 drivers/input/keyboard/nua3500_keypad.c

diff --git a/arch/arm64/boot/dts/nuvoton/nua3500.dtsi b/arch/arm64/boot/dts/nuvoton/nua3500.dtsi
index 5505f17..69a3283 100644
--- a/arch/arm64/boot/dts/nuvoton/nua3500.dtsi
+++ b/arch/arm64/boot/dts/nuvoton/nua3500.dtsi
@@ -12,6 +12,9 @@
  */
 
 #include <dt-bindings/interrupt-controller/arm-gic.h>
+
+#include "dt-bindings/input/input.h"
+
 //#define ENABLE_PSCI
 /{
 	compatible = "nuvoton,nua3500";
@@ -108,13 +111,13 @@
 
 #if 1
 	uart0: serial@40700000 {
-                compatible = "nuvoton,nua3500-uart";
-                reg = <0x0 0x40700000 0x0 0x10000>;
-                interrupts = <GIC_SPI 59 IRQ_TYPE_EDGE_RISING>;
-                port-number = <0>;
-                pdma-enable = <0>;
-                status = "okay";
-        };
+		compatible = "nuvoton,nua3500-uart";
+		reg = <0x0 0x40700000 0x0 0x10000>;
+		interrupts = <GIC_SPI 59 IRQ_TYPE_EDGE_RISING>;
+		port-number = <0>;
+		pdma-enable = <0>;
+		status = "okay";
+	};
 #endif
 
 #if 1   /* USB Host */
@@ -171,6 +174,68 @@
         };
 #endif
 
+	rtc: rtc@40410000 {
+		compatible = "nuvoton,nua3500-rtc";
+		reg = <0x0 0x40410000 0x0 0x10000>;
+		interrupts = <GIC_SPI 5 IRQ_TYPE_EDGE_RISING>;
+		status = "disabled";
+	};
+
+
+	keypad: keypad@404A0000 {
+		compatible = "nuvoton,nua3500-kpi";
+		
+		reg = <0x0 0x404A0000 0x0 0x10000>;
+		interrupts = <GIC_SPI 79 IRQ_TYPE_EDGE_RISING>;
+
+		keypad,num-rows = <4>;
+		keypad,num-columns = <4>;
+
+		linux,keymap = <MATRIX_KEY(0x00, 0x02, KEY_F) /* key_forward */
+		MATRIX_KEY(0x00, 0x03, KEY_HOME) /* key_home */
+		MATRIX_KEY(0x01, 0x00, KEY_A) /* key_contacts */
+		MATRIX_KEY(0x01, 0x01, KEY_1) /* key_1 */
+		MATRIX_KEY(0x01, 0x02, KEY_2) /* key_2 */
+		MATRIX_KEY(0x01, 0x03, KEY_3) /* key_3 */
+		MATRIX_KEY(0x02, 0x00, KEY_P) /* key_phone */
+		MATRIX_KEY(0x02, 0x01, KEY_4) /* key_4 */
+		MATRIX_KEY(0x02, 0x02, KEY_5) /* key_5 */
+		MATRIX_KEY(0x02, 0x03, KEY_6) /* key_6 */
+		MATRIX_KEY(0x03, 0x00, KEY_C) /* key_call_log */
+		MATRIX_KEY(0x03, 0x01, KEY_7) /* key_7 */
+		MATRIX_KEY(0x03, 0x02, KEY_8) /* key_8 */
+		MATRIX_KEY(0x03, 0x03, KEY_9) /* key_9 */
+		>;
+
+
+		/*
+		debounce setting:
+		0 = disable debounce
+		3 = debounce preiod is 8 clocks.
+		4 = debounce preiod is 16 clocks.
+		5 = debounce preiod is 32 clocks.
+		6 = debounce preiod is 64 clocks.
+		7 = debounce preiod is 128 clocks.
+		8 = debounce preiod is 256 clocks.
+		9 = debounce preiod is 512 clocks.
+		10 = debounce preiod is 1024 clocks.
+		11 = debounce preiod is 2048 clocks.
+		12 = debounce preiod is 4096 clocks.
+		13 = debounce preiod is 8192 clocks.
+		*/
+		debounce-period = <1>;
+
+		/* pre-scale is from 1 ~ 256 */
+		per-scale = <1>;
+		
+		/* pre-scale divider is from 1 ~ 256 */
+		per-scalediv = <32>;
+
+		status = "disabled";
+
+	};
+
+
 #if 1
         sdhci0: sdhci@40180000 {
 		compatible = "snps,dwcmshc-sdhci";
diff --git a/arch/arm64/configs/nua3500_defconfig b/arch/arm64/configs/nua3500_defconfig
old mode 100755
new mode 100644
index 5cd3cab..5841cac
--- a/arch/arm64/configs/nua3500_defconfig
+++ b/arch/arm64/configs/nua3500_defconfig
@@ -1195,7 +1195,7 @@ CONFIG_INPUT=y
 # CONFIG_INPUT_FF_MEMLESS is not set
 # CONFIG_INPUT_POLLDEV is not set
 # CONFIG_INPUT_SPARSEKMAP is not set
-# CONFIG_INPUT_MATRIXKMAP is not set
+CONFIG_INPUT_MATRIXKMAP=y
 
 #
 # Userland interfaces
@@ -1208,7 +1208,21 @@ CONFIG_INPUT_EVDEV=y
 #
 # Input Device Drivers
 #
-# CONFIG_INPUT_KEYBOARD is not set
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_BCM is not set
+CONFIG_KEYBOARD_NUA3500=y
 # CONFIG_INPUT_MOUSE is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TABLET is not set
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index 8911bc2..13eacdf 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -766,6 +766,16 @@ config KEYBOARD_BCM
 	  To compile this driver as a module, choose M here: the
 	  module will be called bcm-keypad.
 
+config KEYBOARD_NUA3500
+	tristate "nuvoton nua3500 keypad driver"
+	depends on ARCH_NUA3500
+	select INPUT_MATRIXKMAP
+	help
+	  Say Y here if you want to use Nuvoton NUA3500 keypad.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called nua3500-keypad.
+
 config KEYBOARD_MTK_PMIC
 	tristate "MediaTek PMIC keys support"
 	depends on MFD_MT6397
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index 9510325..30b432a 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -45,6 +45,7 @@ obj-$(CONFIG_KEYBOARD_MTK_PMIC) 	+= mtk-pmic-keys.o
 obj-$(CONFIG_KEYBOARD_NEWTON)		+= newtonkbd.o
 obj-$(CONFIG_KEYBOARD_NOMADIK)		+= nomadik-ske-keypad.o
 obj-$(CONFIG_KEYBOARD_NSPIRE)		+= nspire-keypad.o
+obj-$(CONFIG_KEYBOARD_NUA3500)		+= nua3500_keypad.o
 obj-$(CONFIG_KEYBOARD_OMAP)		+= omap-keypad.o
 obj-$(CONFIG_KEYBOARD_OMAP4)		+= omap4-keypad.o
 obj-$(CONFIG_KEYBOARD_OPENCORES)	+= opencores-kbd.o
diff --git a/drivers/input/keyboard/nua3500_keypad.c b/drivers/input/keyboard/nua3500_keypad.c
new file mode 100644
index 0000000..fa41928
--- /dev/null
+++ b/drivers/input/keyboard/nua3500_keypad.c
@@ -0,0 +1,366 @@
+/*
+ * Copyright (c) 2020 Nuvoton technology corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/input/matrix_keypad.h>
+#include <linux/clk.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+/* Keypad Interface Control Registers */
+#define KPI_CONF		0x00
+#define KPI_3KCONF		0x04
+#define KPI_STATUS		0x08
+#define KPI_RSTC		0x0C
+#define KPI_KEST		0x10
+#define KPI_KPE0		0x18
+#define KPI_KPE1		0x1C
+#define KPI_KRE0		0x20
+#define KPI_KRE1		0x24
+#define KPI_PRESCALDIV	0x28
+
+// KPI_CONF
+#define KROW		(0x70000000)	// Keypad Matrix ROW number
+#define KCOL		(0x07000000)	// Keypad Matrix COL Number
+#define DB_EN		(0x00200000)	// Scan In Signal De-bounce Enable
+#define DB_CLKSEL	(0x000F0000)	// Scan In De-bounce sampling cycle selection
+#define PRESCALE	(0x0000FF00)	// Row Scan Cycle Pre-scale Value
+#define INPU		(0x00000040)	// key Scan In Pull-UP Enable Register
+#define WAKEUP		(0x00000020)	// Lower Power Wakeup Enable
+#define ODEN		(0x00000010)	// Open Drain Enable
+#define INTEN		(0x00000008)	// Key Interrupt Enable Control
+#define RKINTEN 	(0x00000004)	// Release Key Interrupt Enable Control
+#define PKINTEN 	(0x00000002)	// Press Key Interrupt Enable Control
+#define ENKP		(0x00000001)	// Keypad Scan Enable
+
+// KPI_STATUS
+#define RROW7		(0x00800000)	// Release key row coordinate
+#define RROW6		(0x00400000)
+#define RROW5		(0x00200000)
+#define RROW4		(0x00100000)
+#define RROW3		(0x00080000)
+#define RROW2		(0x00040000)
+#define RROW1		(0x00020000)
+#define RROW0		(0x00010000)
+#define PROW7		(0x00008000)	// Press key row coordinate
+#define PROW6		(0x00004000)
+#define PROW5		(0x00002000)
+#define PROW4		(0x00001000)
+#define PROW3		(0x00000800)
+#define PROW2		(0x00000400)
+#define PROW1		(0x00000200)
+#define PROW0		(0x00000100)
+#define PKEY_INT	(0x00000010)	// Press key interrupt
+#define RKEY_INT	(0x00000008)	// Release key interrupt
+#define KEY_INT		(0x00000004)	// Key Interrupt
+#define RST_3KEY	(0x00000002)	// 3-Keys Reset Flag
+#define PDWAKE		(0x00000001)	// Power Down Wakeup Flag
+
+#define PROW 		(0x00000f00)	// Press Key Row Coordinate
+
+#define KPI_PRESCALE	(8)
+#define DEBOUNCE_BIT	(16)
+
+#define nua3500_NUM_ROWS		8
+#define nua3500_NUM_COLS		8
+
+
+struct nua3500_keypad {
+	//const struct nua3500_keypad_platform_data *pdata;
+	struct clk *clk;
+	struct input_dev *input_dev;
+	void __iomem *mmio_base;
+	int irq;
+	unsigned int kpi_row;
+	unsigned int kpi_col;
+	unsigned int debounce_val;
+	unsigned int pre_scale;
+	unsigned int pre_scale_divider;
+};
+
+
+
+void nua3500_keypad_mfp_set(struct platform_device *pdev)
+{
+
+}
+
+static void nua3500_keypad_scan_matrix(struct nua3500_keypad *keypad, unsigned int status)
+{
+	struct input_dev *input_dev = keypad->input_dev;
+	unsigned int i, j;
+	unsigned int row_add = 0;
+	unsigned int code;
+	unsigned int key;
+	unsigned int press_key;
+	unsigned long KeyEvent[4];
+	unsigned int row_shift = get_count_order(keypad->kpi_col);
+	unsigned short *keymap = input_dev->keycode;
+
+	KeyEvent[0] = __raw_readl(keypad->mmio_base + KPI_KPE0);
+	KeyEvent[1] = __raw_readl(keypad->mmio_base + KPI_KPE1);
+	KeyEvent[2] = __raw_readl(keypad->mmio_base + KPI_KRE0);
+	KeyEvent[3] = __raw_readl(keypad->mmio_base + KPI_KRE1);
+
+	__raw_writel(KeyEvent[0], (keypad->mmio_base + KPI_KPE0));
+	__raw_writel(KeyEvent[1], (keypad->mmio_base + KPI_KPE1));
+	__raw_writel(KeyEvent[2], (keypad->mmio_base + KPI_KRE0));
+	__raw_writel(KeyEvent[3], (keypad->mmio_base + KPI_KPE1));
+
+	for(j = 0; j < 4; j++){
+		if(KeyEvent[j] != 0){
+			if((j == 1) || (j == 3)) row_add = 4;
+			else row_add = 0;
+
+			if(j < 2) press_key = 1;
+			else press_key = 0;
+
+			for (i=0; i<32; i++){
+				if(KeyEvent[j] & (1<<i)){
+					code = MATRIX_SCAN_CODE( ((i << 3) + row_add), (i & 0x7), row_shift);
+					key = keymap[code];
+
+					input_event(input_dev, EV_MSC, MSC_SCAN, code);
+					input_report_key(input_dev, key, press_key);
+					input_sync(input_dev);
+				}
+			}
+		}
+	}
+}
+
+static irqreturn_t nua3500_keypad_irq_handler(int irq, void *dev_id)
+{
+	struct nua3500_keypad *keypad = dev_id;
+	unsigned int  kstatus;
+
+	kstatus = __raw_readl(keypad->mmio_base + KPI_STATUS);
+
+	if (kstatus & (PKEY_INT|RKEY_INT)){
+		nua3500_keypad_scan_matrix(keypad, kstatus);
+	}
+	else{
+		if(kstatus & PDWAKE)
+			__raw_writel(PDWAKE, (keypad->mmio_base + KPI_STATUS));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int nua3500_keypad_open(struct input_dev *dev)
+{
+	struct nua3500_keypad *keypad = input_get_drvdata(dev);
+	unsigned int val, config;
+
+	val = INPU | RKINTEN | PKINTEN | INTEN | ENKP;
+
+	val |= (((keypad->kpi_row) - 1) << 28) | (((keypad->kpi_col) - 1) << 24);
+
+	if(keypad->debounce_val > 0)
+		config = ((keypad->pre_scale - 1) << KPI_PRESCALE) | (keypad->debounce_val << DEBOUNCE_BIT) | DB_EN;
+	else
+		config = ((keypad->pre_scale - 1) << KPI_PRESCALE);
+
+	val |= config;
+
+	__raw_writel(val, keypad->mmio_base + KPI_CONF);
+
+	__raw_writel((keypad->pre_scale_divider - 1), keypad->mmio_base + KPI_PRESCALDIV);
+
+	return 0;
+}
+
+static void nua3500_keypad_close(struct input_dev *dev)
+{
+	struct nua3500_keypad *keypad = input_get_drvdata(dev);
+
+	/* Disable clock unit */
+	clk_disable(keypad->clk);
+}
+
+static int nua3500_keypad_probe(struct platform_device *pdev)
+{
+	struct nua3500_keypad *keypad;
+	struct input_dev *input_dev;
+	struct resource *res;
+	int irq;
+	int error = 0;
+
+	keypad = devm_kzalloc(&pdev->dev, sizeof(*keypad), GFP_KERNEL);
+
+	input_dev = input_allocate_device();
+	if (!keypad || !input_dev) {
+		dev_err(&pdev->dev, "failed to allocate driver data\n");
+		error = -ENOMEM;
+		goto failed_free;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get I/O memory\n");
+		error = -ENXIO;
+		goto failed_free;
+	}
+
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to request I/O memory\n");
+		error = -EBUSY;
+		goto failed_free;
+	}
+
+	keypad->mmio_base = ioremap(res->start, resource_size(res));
+	if (keypad->mmio_base == NULL) {
+		dev_err(&pdev->dev, "failed to remap I/O memory\n");
+		error = -ENXIO;
+		goto failed_free_res;
+	}
+
+	keypad->input_dev = input_dev;
+	keypad->irq = platform_get_irq(pdev, 0);;
+
+	input_dev->name = pdev->name;
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->open = nua3500_keypad_open;
+	input_dev->close = nua3500_keypad_close;
+	input_dev->dev.parent = &pdev->dev;
+
+	/* Enable clock */
+
+
+	error = matrix_keypad_parse_properties(&pdev->dev, &(keypad->kpi_row), &(keypad->kpi_col));
+	if (error) {
+		dev_err(&pdev->dev, "failed to parse kp params\n");
+		return error;
+	}
+
+	error = matrix_keypad_build_keymap(NULL, NULL, keypad->kpi_row, keypad->kpi_col, NULL, input_dev);
+	if (error) {
+		dev_err(&pdev->dev, "failed to build keymap\n");
+		goto failed_put_clk;
+	}
+
+	error = request_irq(keypad->irq, nua3500_keypad_irq_handler,
+			    IRQF_NO_SUSPEND, pdev->name, keypad);
+	if (error) {
+		dev_err(&pdev->dev, "failed to request IRQ\n");
+		goto failed_put_clk;
+	}
+
+	of_property_read_u32(pdev->dev.of_node, "debounce-period", &(keypad->debounce_val));
+
+	of_property_read_u32(pdev->dev.of_node, "per-scale", &(keypad->pre_scale));
+
+	of_property_read_u32(pdev->dev.of_node, "per-scalediv", &(keypad->pre_scale_divider));
+
+	__set_bit(EV_REP, input_dev->evbit);
+	input_set_capability(input_dev, EV_MSC, MSC_SCAN);
+	input_set_drvdata(input_dev, keypad);
+
+	/* Register the input device */
+	error = input_register_device(input_dev);
+	if (error) {
+		dev_err(&pdev->dev, "failed to register input device\n");
+		goto failed_free_irq;
+	}
+
+	platform_set_drvdata(pdev, keypad);
+	return 0;
+
+failed_free_irq:
+	free_irq(irq, pdev);
+failed_put_clk:
+	clk_put(keypad->clk);
+
+	iounmap(keypad->mmio_base);
+failed_free_res:
+	release_mem_region(res->start, resource_size(res));
+failed_free:
+	input_free_device(input_dev);
+	kfree(keypad);
+
+	dev_err(&pdev->dev, "probe failed\n");
+
+	return error;
+}
+
+static int nua3500_keypad_remove(struct platform_device *pdev)
+{
+	struct nua3500_keypad *keypad = platform_get_drvdata(pdev);
+	struct resource *res;
+
+	free_irq(keypad->irq, pdev);
+
+	clk_put(keypad->clk);
+
+	input_unregister_device(keypad->input_dev);
+
+	iounmap(keypad->mmio_base);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	platform_set_drvdata(pdev, NULL);
+	kfree(keypad);
+
+	return 0;
+}
+
+static int nua3500_keypad_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct nua3500_keypad *keypad = platform_get_drvdata(pdev);
+
+	__raw_writel(__raw_readl(keypad->mmio_base + KPI_CONF) | WAKEUP, keypad->mmio_base + KPI_CONF);
+	enable_irq_wake(keypad->irq);
+
+	return 0;
+}
+
+static int nua3500_keypad_resume(struct platform_device *pdev)
+{
+	struct nua3500_keypad *keypad = platform_get_drvdata(pdev);
+
+	__raw_writel(__raw_readl(keypad->mmio_base + KPI_CONF) & ~(WAKEUP), keypad->mmio_base + KPI_CONF);
+	disable_irq_wake(keypad->irq);
+
+	return 0;
+}
+
+static const struct of_device_id nua3500_kpi_of_match[] = {
+	{ .compatible = "nuvoton,nua3500-kpi"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, nua3500_kpi_of_match);
+
+static struct platform_driver nua3500_keypad_driver = {
+	.probe		= nua3500_keypad_probe,
+	.remove		= nua3500_keypad_remove,
+	.suspend	= nua3500_keypad_suspend,
+	.resume		= nua3500_keypad_resume,
+	.driver		= {
+		.name	= "nua3500-kpi",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(nua3500_kpi_of_match),
+	},
+};
+module_platform_driver(nua3500_keypad_driver);
+
+MODULE_AUTHOR("nuvoton");
+MODULE_DESCRIPTION("nua3500 keypad driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:nua3500-keypad");
-- 
2.0.3

