From f21e5105ea71b3b7ff4caf47d6ee12e70d8bc318 Mon Sep 17 00:00:00 2001
From: "Y.C. Huang" <ychuang3@nuvoton.com>
Date: Fri, 31 Jul 2020 16:44:06 +0800
Subject: [PATCH 6/7] KS - Add Key Store driver.

Change-Id: I55b705ec8d1b911ac357725e3800cb290ba89119
---
 arch/arm64/boot/dts/nuvoton/nua3500.dtsi |  12 +-
 drivers/misc/Kconfig                     |   6 +
 drivers/misc/Makefile                    |   1 +
 drivers/misc/nua3500_ks.c                | 582 +++++++++++++++++++++++++++++++
 include/uapi/misc/nua3500_ks.h           | 112 ++++++
 5 files changed, 708 insertions(+), 5 deletions(-)
 create mode 100644 drivers/misc/nua3500_ks.c
 create mode 100644 include/uapi/misc/nua3500_ks.h

diff --git a/arch/arm64/boot/dts/nuvoton/nua3500.dtsi b/arch/arm64/boot/dts/nuvoton/nua3500.dtsi
index 98e623a..5505f17 100644
--- a/arch/arm64/boot/dts/nuvoton/nua3500.dtsi
+++ b/arch/arm64/boot/dts/nuvoton/nua3500.dtsi
@@ -108,11 +108,13 @@
 
 #if 1
 	uart0: serial@40700000 {
-		compatible = "nuvoton,nua3500-uart";
-		reg = <0x0 0x40700000 0x0 0x10000>;
-		interrupts = <GIC_SPI 59 IRQ_TYPE_EDGE_RISING>;
-		status = "okay";
-	};
+                compatible = "nuvoton,nua3500-uart";
+                reg = <0x0 0x40700000 0x0 0x10000>;
+                interrupts = <GIC_SPI 59 IRQ_TYPE_EDGE_RISING>;
+                port-number = <0>;
+                pdma-enable = <0>;
+                status = "okay";
+        };
 #endif
 
 #if 1   /* USB Host */
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index c55b637..e9d7465 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -466,6 +466,12 @@ config PVPANIC
 	  a paravirtualized device provided by QEMU; it lets a virtual machine
 	  (guest) communicate panic events to the host.
 
+config NUA3500_KS
+	tristate "Nuvoton NUA3500 Key Store support"
+	depends on ARCH_NUA3500
+	help
+	  This driver provides support for Nuvoton NUA3500 Key Store.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index c1860d3..71f2e9d 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -57,3 +57,4 @@ obj-y				+= cardreader/
 obj-$(CONFIG_PVPANIC)   	+= pvpanic.o
 obj-$(CONFIG_HABANA_AI)		+= habanalabs/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
+obj-$(CONFIG_NUA3500_KS)   	+= nua3500_ks.o
diff --git a/drivers/misc/nua3500_ks.c b/drivers/misc/nua3500_ks.c
new file mode 100644
index 0000000..6011841
--- /dev/null
+++ b/drivers/misc/nua3500_ks.c
@@ -0,0 +1,582 @@
+/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
+/*
+ * Nuvoton NUA3500 Key Store
+ *
+ * Copyright (c) 2020 Nuvoton technology corporation.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/miscdevice.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/of_platform.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/compat.h>
+#include <linux/highmem.h>
+
+#include <uapi/misc/nua3500_ks.h>
+
+#define DEV_NAME_LEN 12
+
+
+#define KS_CTL			0x00
+#define KS_CTL_START			(0x1 << 0)
+#define KS_CTL_OPMODE_Pos       	1
+#define KS_CTL_OPMODE_Msk		(0x7 << 1)
+#define KS_CTL_CONT	           	(0x1 << 7)
+#define KS_CTL_INIT	           	(0x1 << 8)
+#define KS_CTL_SILENT	         	(0x1 << 10)
+#define KS_CTL_SCMB     	      	(0x1 << 11)
+#define KS_CTL_TCLR	           	(0x1 << 14)
+#define KS_CTL_IEN	            	(0x1 << 15)
+#define KS_METADATA		0x04
+#define KS_STS			0x08
+#define KS_STS_IF	             	(0x1 << 0)
+#define KS_STS_EIF	            	(0x1 << 1)
+#define KS_STS_BUSY	           	(0x1 << 2)
+#define KS_STS_SRAMFULL	       		(0x1 << 3)
+#define KS_STS_INITDONE		       	(0x1 << 7)
+#define KS_STS_RAMINV_Pos	        8
+#define KS_STS_RAMINV_Msk		(0xFFFFFF << 8)
+#define KS_REMAIN		0x0C
+#define KS_REMAIN_RRMNG_Pos		0
+#define KS_REMAIN_RRMNG_Msk		(0x1FFF << 0)
+#define KS_SCMBKEY(x)		(0x10 + ((x) * 0x04))
+#define KS_KEY(x)		(0x20 + ((x) * 0x04))
+#define KS_OTPSTS		0x40
+
+#define KS_CLT_FUNC_MASK        (KS_CTL_IEN | KS_CTL_TCLR | KS_CTL_SCMB | KS_CTL_SILENT)
+
+#define KS_OP_READ          	(0x0 << KS_CTL_OPMODE_Pos)
+#define KS_OP_WRITE             (0x1 << KS_CTL_OPMODE_Pos)
+#define KS_OP_ERASE             (0x2 << KS_CTL_OPMODE_Pos)
+#define KS_OP_ERASE_ALL         (0x3 << KS_CTL_OPMODE_Pos)
+#define KS_OP_REVOKE            (0x4 << KS_CTL_OPMODE_Pos)
+#define KS_OP_REMAN             (0x5 << KS_CTL_OPMODE_Pos)
+
+struct nua3500_ks_dev {
+	struct device *dev;
+	struct miscdevice miscdev;
+	wait_queue_head_t waitq;
+	char dev_name[DEV_NAME_LEN];
+	void __iomem  *reg_base;
+	int  irq;
+	int  int_err_sts;
+};
+
+struct clk *ks_clk;
+
+static uint16_t au8SRAMCntTbl[21] = {4,6,6,7,8,8,8,9,12,13,16,17,18,0,0,0,32,48,64,96,128};
+static uint16_t au8OTPCntTbl[7] = {4,6,6,7,8,8,8};
+
+
+static inline u32  nu_ks_read_reg(struct nua3500_ks_dev *ks_dev, u32 offset)
+{
+	u32 value = readl_relaxed(ks_dev->reg_base + offset);
+
+	dev_vdbg(ks_dev->dev, "reg read 0x%08x from <0x%x>\n", value, offset);
+	return value;
+}
+
+static inline void nu_ks_write_reg(struct nua3500_ks_dev *ks_dev, u32 offset, u32 value)
+{
+	dev_vdbg(ks_dev->dev, "write 0x%08x into <0x%x>\n", value, offset);
+	writel_relaxed(value, ks_dev->reg_base + offset);
+}
+
+
+static int nua3500_ks_read(struct nua3500_ks_dev *ks_dev, void __user *arg)
+{
+	struct ks_read_args  r_args;
+	int         err, remain_cnt;
+	u32         cont_msk;
+	int         offset, i, cnt;
+
+	err = copy_from_user(&r_args, arg, sizeof(r_args));
+	if (err)
+		return -EFAULT;
+
+	/* Just return when key store is in busy */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY) {
+		pr_err("NUA3500 KS is busy!\n");
+		return -EBUSY;
+	}
+
+	/* Specify the key address */
+	nu_ks_write_reg(ks_dev, KS_METADATA,
+			(r_args.type << KS_METADATA_DST_Pos) | KS_TOMETAKEY(r_args.key_idx));
+
+	/* Clear error flag */
+	nu_ks_write_reg(ks_dev, KS_STS, KS_STS_EIF);
+	offset = 0;
+	cont_msk = 0;
+	remain_cnt = r_args.word_cnt;
+
+	do {
+
+		/* Clear Status */
+		nu_ks_write_reg(ks_dev, KS_STS, KS_STS_EIF | KS_STS_IF);
+		// printk("nu_ks_read_reg - META=0x%x, CTL=0x%x\n",
+		//		nu_ks_read_reg(ks_dev, KS_METADATA), cont_msk | KS_OP_READ | KS_CTL_START | (nu_ks_read_reg(ks_dev, KS_CTL) & KS_CLT_FUNC_MASK));
+
+		/* Trigger to read the key */
+		nu_ks_write_reg(ks_dev, KS_CTL,
+					cont_msk | KS_OP_READ | KS_CTL_START | (nu_ks_read_reg(ks_dev, KS_CTL) & KS_CLT_FUNC_MASK));
+
+		/* Waiting for key store processing */
+		while (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY);
+
+		/* Read the key to key buffer */
+		cnt = remain_cnt;
+		if (cnt > 8)
+			cnt = 8;
+		for (i = 0; i < cnt; i++) {
+			r_args.key[offset+i] = nu_ks_read_reg(ks_dev, KS_KEY(i));
+			 // printk("KS_Read R[%d]:0x%08x\n", i, r_args.key[offset+i]);
+		}
+
+		cont_msk = KS_CTL_CONT;
+		remain_cnt -= 8;
+		offset += 8;
+
+	} while(remain_cnt > 0);
+
+	// printk("KS_STS (after KS_Read): 0x%x\n", nu_ks_read_reg(ks_dev, KS_STS));
+
+	/* Check error flag */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_EIF) {
+		pr_err("KS EIF set on reading keys!\n");
+		return -EIO;
+	}
+
+	err = copy_to_user(arg, &r_args, sizeof(r_args));
+	if (err)
+		err = -EFAULT;
+
+	return err;
+}
+
+static int nua3500_ks_write_sram(struct nua3500_ks_dev *ks_dev, void __user *arg)
+{
+	struct ks_write_args  w_args;
+	int         err, remain_cnt;
+	u32         cont_msk;
+	int         offset, i, cnt;
+
+	err = copy_from_user(&w_args, arg, sizeof(w_args));
+	if (err)
+		return -EFAULT;
+
+	/* Just return when key store is in busy */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY) {
+		pr_err("NUA3500 KS is busy!\n");
+		return -EBUSY;
+	}
+
+	/* Specify the key address */
+	nu_ks_write_reg(ks_dev, KS_METADATA, (KS_SRAM << KS_METADATA_DST_Pos) | w_args.meta_data);
+
+	/* Get key size by indexing to size table */
+	i = ((w_args.meta_data & KS_METADATA_SIZE_Msk) >> KS_METADATA_SIZE_Pos);
+	remain_cnt = au8SRAMCntTbl[i];
+
+	/* Invalid key length */
+	if (remain_cnt == 0) {
+		pr_err("Invalid key length!\n");
+		return -EINVAL;
+	}
+
+	/* Clear error flag */
+	nu_ks_write_reg(ks_dev, KS_STS, KS_STS_EIF);
+	offset = 0;
+	cont_msk = 0;
+	do {
+		/* Prepare the key to write */
+		cnt = remain_cnt;
+		if (cnt > 8)
+			cnt = 8;
+		for (i = 0; i < cnt; i++) {
+			// printk("w 0x%lx\n", w_args.key[offset+i]);
+			nu_ks_write_reg(ks_dev, KS_KEY(i), w_args.key[offset+i]);
+		}
+
+		/* Clear Status */
+		nu_ks_write_reg(ks_dev, KS_STS, KS_STS_EIF | KS_STS_IF);
+
+		/* Write the key */
+		nu_ks_write_reg(ks_dev, KS_CTL,
+				cont_msk | KS_OP_WRITE | KS_CTL_START | (nu_ks_read_reg(ks_dev, KS_CTL) & KS_CLT_FUNC_MASK));
+
+		cont_msk = KS_CTL_CONT;
+		remain_cnt -= 8;
+		offset += 8;
+
+		/* Waiting for key store processing */
+		while (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY);
+
+	} while (remain_cnt > 0);
+
+	/* Check error flag */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_EIF) {
+		pr_err("KS EIF set on writing SRAM keys!\n");
+		return -EIO;
+	}
+
+	return KS_TOKEYIDX(nu_ks_read_reg(ks_dev, KS_METADATA));
+}
+
+static int nua3500_ks_write_otp(struct nua3500_ks_dev *ks_dev, void __user *arg)
+{
+	struct ks_write_args  w_args;
+	int         err, remain_cnt;
+	u32         cont_msk;
+	int         sidx, offset, i, cnt;
+
+	err = copy_from_user(&w_args, arg, sizeof(w_args));
+	if (err)
+		return -EFAULT;
+
+	/* Just return when key store is in busy */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY) {
+		pr_err("NUA3500 KS is busy!\n");
+		return -EBUSY;
+	}
+
+	/* Specify the key address */
+	nu_ks_write_reg(ks_dev, KS_METADATA,
+			(KS_OTP << KS_METADATA_DST_Pos) | w_args.meta_data | KS_TOMETAKEY(w_args.key_idx));
+
+	/* Get size index */
+	sidx = (w_args.meta_data >> KS_METADATA_SIZE_Pos) & 0xful;
+
+	/* OTP only support maximum 256 bits */
+	if (sidx >= 7)
+	return -1;
+
+	remain_cnt = au8OTPCntTbl[sidx];
+
+	/* Clear error flag */
+	nu_ks_write_reg(ks_dev, KS_STS, KS_STS_EIF);
+	offset = 0;
+	cont_msk = 0;
+	do  {
+		/* Prepare the key to write */
+		cnt = remain_cnt;
+		if (cnt > 8)
+			cnt = 8;
+		for (i = 0; i < cnt; i++) {
+			nu_ks_write_reg(ks_dev, KS_KEY(i), w_args.key[offset+i]);
+		}
+
+		/* Clear Status */
+		nu_ks_write_reg(ks_dev, KS_STS, KS_STS_EIF | KS_STS_IF);
+
+		/* Write the key */
+		nu_ks_write_reg(ks_dev, KS_CTL,
+				cont_msk | KS_OP_WRITE | KS_CTL_START | (nu_ks_read_reg(ks_dev, KS_CTL) & KS_CLT_FUNC_MASK));
+
+		cont_msk = KS_CTL_CONT;
+		remain_cnt -= 8;
+		offset += 8;
+
+		/* Waiting for key store processing */
+		while (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY);
+
+	} while (remain_cnt > 0);
+
+	/* Check error flag */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_EIF) {
+		pr_err("KS EIF set on writing OTP keys!\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static int nua3500_ks_erase(struct nua3500_ks_dev *ks_dev, void __user *arg)
+{
+	struct ks_kidx_args  k_args;
+	int   err;
+
+	err = copy_from_user(&k_args, arg, sizeof(k_args));
+	if (err)
+		return -EFAULT;
+
+	/* Just return when key store is in busy */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY) {
+		pr_err("NUA3500 KS is busy!\n");
+		return -EBUSY;
+	}
+
+	/* Specify the key address */
+	nu_ks_write_reg(ks_dev, KS_METADATA,
+			(k_args.type << KS_METADATA_DST_Pos) | KS_TOMETAKEY(k_args.key_idx));
+
+	/* Clear Status */
+	nu_ks_write_reg(ks_dev, KS_STS, KS_STS_EIF | KS_STS_IF);
+
+	/* Erase the key */
+	nu_ks_write_reg(ks_dev, KS_CTL,
+			KS_OP_ERASE | KS_CTL_START  | (nu_ks_read_reg(ks_dev, KS_CTL) & KS_CLT_FUNC_MASK));
+
+	/* Waiting for processing */
+	while (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY);
+
+	/* Check error flag */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_EIF) {
+		pr_err("KS EIF set on erasing a key!\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static int nua3500_ks_erase_all(struct nua3500_ks_dev *ks_dev)
+{
+	/* Just return when key store is in busy */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY) {
+		pr_err("NUA3500 KS is busy!\n");
+		return -EBUSY;
+	}
+
+	/* Specify the key address */
+	nu_ks_write_reg(ks_dev, KS_METADATA, (KS_SRAM << KS_METADATA_DST_Pos));
+
+	/* Clear Status */
+	nu_ks_write_reg(ks_dev, KS_STS, KS_STS_EIF | KS_STS_IF);
+
+	/* Erase the key */
+	nu_ks_write_reg(ks_dev, KS_CTL,
+				KS_OP_ERASE_ALL | KS_CTL_START  | (nu_ks_read_reg(ks_dev, KS_CTL) & KS_CLT_FUNC_MASK));
+	/* Waiting for processing */
+	while (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY);
+
+	/* Check error flag */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_EIF) {
+		pr_err("KS EIF set on erase-all!\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static int nua3500_ks_revoke(struct nua3500_ks_dev *ks_dev, void __user *arg)
+{
+	struct ks_kidx_args  k_args;
+	int   err;
+
+	err = copy_from_user(&k_args, arg, sizeof(k_args));
+	if (err)
+		return -EFAULT;
+
+	/* Just return when key store is in busy */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY) {
+		pr_err("NUA3500 KS is busy!\n");
+		return -EBUSY;
+	}
+
+	/* Specify the key address */
+	nu_ks_write_reg(ks_dev, KS_METADATA, (k_args.type << KS_METADATA_DST_Pos) | KS_TOMETAKEY(k_args.key_idx));
+
+	/* Clear Status */
+	nu_ks_write_reg(ks_dev, KS_STS, KS_STS_EIF | KS_STS_IF);
+
+	/* Erase the key */
+	nu_ks_write_reg(ks_dev, KS_CTL,
+			KS_OP_REVOKE | KS_CTL_START | (nu_ks_read_reg(ks_dev, KS_CTL) & KS_CLT_FUNC_MASK));
+
+	/* Waiting for processing */
+	while (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY);
+
+	/* Check error flag */
+	if (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_EIF) {
+		pr_err("KS EIF set on revoking a key!\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static int nua3500_ks_remain(struct nua3500_ks_dev *ks_dev)
+{
+	u32   reg_data, sram_remain;
+
+	reg_data = nu_ks_read_reg(ks_dev, KS_REMAIN);
+	sram_remain = (reg_data & KS_REMAIN_RRMNG_Msk) >> KS_REMAIN_RRMNG_Pos;
+	return sram_remain;
+}
+
+static int ks_dev_open(struct inode *iptr, struct file *fptr)
+{
+	struct nua3500_ks_dev *ks_dev;
+
+	ks_dev = container_of(fptr->private_data, struct nua3500_ks_dev, miscdev);
+
+	/* Start Key Store Initial */
+	nu_ks_write_reg(ks_dev, KS_CTL, KS_CTL_INIT | KS_CTL_START);
+
+	/* Waiting for initilization */
+	while ((nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_INITDONE) == 0) {}
+
+	/* Waiting for processing */
+	while (nu_ks_read_reg(ks_dev, KS_STS) & KS_STS_BUSY) {}
+
+	return 0;
+}
+
+static int ks_dev_release(struct inode *iptr, struct file *fptr)
+{
+	return 0;
+}
+
+static long ks_dev_ioctl(struct file *fptr, unsigned int cmd,
+				 unsigned long data)
+{
+	struct nua3500_ks_dev *ks_dev;
+	char __user *argp = (char __user *)data;
+	int rval = -EINVAL;
+
+	ks_dev = container_of(fptr->private_data, struct nua3500_ks_dev, miscdev);
+
+	if (_IOC_TYPE(cmd) != NUA3500_KS_MAGIC)
+		return -ENOTTY;
+
+	switch (cmd) {
+	case NU_KS_IOCTL_READ:
+		rval = nua3500_ks_read(ks_dev, argp);
+		break;
+	case NU_KS_IOCTL_WRITE_SRAM:
+		rval = nua3500_ks_write_sram(ks_dev, argp);
+		break;
+	case NU_KS_IOCTL_WRITE_OTP:
+		rval = nua3500_ks_write_otp(ks_dev, argp);
+		break;
+	case NU_KS_IOCTL_ERASE:
+		rval = nua3500_ks_erase(ks_dev, argp);
+		break;
+	case NU_KS_IOCTL_ERASE_ALL:
+		rval = nua3500_ks_erase_all(ks_dev);
+		break;
+	case NU_KS_IOCTL_REVOKE:
+		rval = nua3500_ks_revoke(ks_dev, argp);
+		break;
+	case NU_KS_IOCTL_GET_REMAIN:
+		rval = nua3500_ks_remain(ks_dev);
+		break;
+	default:
+		/* Should not get here */
+		break;
+	}
+	return rval;
+}
+
+static const struct file_operations nua3500_ks_fops = {
+	.owner = THIS_MODULE,
+	.open = ks_dev_open,
+	.release = ks_dev_release,
+	.unlocked_ioctl = ks_dev_ioctl,
+	.compat_ioctl = ks_dev_ioctl,
+};
+
+
+static int nua3500_ks_probe(struct platform_device *pdev)
+{
+	struct nua3500_ks_dev *ks_dev;
+	struct device *dev;
+	struct resource *res;
+	int err;
+
+	ks_dev = devm_kzalloc(&pdev->dev, sizeof(*ks_dev), GFP_KERNEL);
+	if (!ks_dev)
+		return -ENOMEM;
+
+	ks_dev->dev = &pdev->dev;
+
+	dev = ks_dev->dev;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ks_dev->reg_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(ks_dev->reg_base)) {
+		err = PTR_ERR(ks_dev->reg_base);
+		goto err_ks_dev;
+	}
+
+	ks_dev->irq = platform_get_irq(pdev, 0);
+	if (ks_dev->irq < 0) {
+		dev_dbg(dev, "platform_get_irq failed");
+		goto err_ks_dev;
+	}
+
+	/* Save driver private data */
+	platform_set_drvdata(pdev, ks_dev);
+
+	snprintf(ks_dev->dev_name, DEV_NAME_LEN, "ks_dev");
+	ks_dev->miscdev.minor = MISC_DYNAMIC_MINOR;
+	ks_dev->miscdev.name = ks_dev->dev_name;
+	ks_dev->miscdev.fops = &nua3500_ks_fops;
+	ks_dev->miscdev.parent = dev;
+	err = misc_register(&ks_dev->miscdev);
+	if (err) {
+		dev_err(dev, "error:%d. Unable to register device", err);
+		goto err_ks_dev;
+	}
+	return 0;
+
+err_ks_dev:
+	return err;
+}
+
+static int nua3500_ks_remove(struct platform_device *pdev)
+{
+	struct nua3500_ks_dev *ks_dev;
+
+	ks_dev = platform_get_drvdata(pdev);
+	misc_deregister(&ks_dev->miscdev);
+	return 0;
+}
+
+static const struct of_device_id nua3500_ks_of_match[] = {
+	{
+		.compatible = "nuvoton,nua3500-ks",
+	},
+	{ /* end of table */ }
+};
+MODULE_DEVICE_TABLE(of, nua3500_ks_of_match);
+
+static struct platform_driver nua3500_ks_driver = {
+	.driver = {
+		.name = "nua3500 key store",
+		.of_match_table = nua3500_ks_of_match,
+	},
+	.probe = nua3500_ks_probe,
+	.remove =  nua3500_ks_remove,
+};
+
+static int __init nua3500_ks_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&nua3500_ks_driver);
+	if (err < 0) {
+		pr_err("%s Unabled to register NUA3500 KS driver", __func__);
+		return err;
+	}
+	return 0;
+}
+
+static void __exit nua3500_ks_exit(void)
+{
+	platform_driver_unregister(&nua3500_ks_driver);
+}
+
+module_init(nua3500_ks_init);
+module_exit(nua3500_ks_exit);
+
+MODULE_AUTHOR("Nuvoton, Inc");
+MODULE_DESCRIPTION("Nuvoton NUA3500 Key Store Driver");
+MODULE_LICENSE("GPL");
diff --git a/include/uapi/misc/nua3500_ks.h b/include/uapi/misc/nua3500_ks.h
new file mode 100644
index 0000000..3b3f103
--- /dev/null
+++ b/include/uapi/misc/nua3500_ks.h
@@ -0,0 +1,112 @@
+/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
+/*
+ * Nuvoton NUA3500 Key Store
+ *
+ * Copyright (c) 2020 Nuvoton technology corporation.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;version 2 of the License.
+ *
+ */
+#ifndef __NUA3500_KS_H__
+#define __NUA3500_KS_H__
+
+#include <linux/types.h>
+
+#define KS_MAX_KEY_SIZE     	  (4096)
+
+#define KS_SRAM_KEY_CNT     	  (32)
+#define KS_OTP_KEY_CNT      	  (9)
+
+#define KS_METADATA_SEC_Msk       (1<<0)
+#define KS_METADATA_PRIV_Msk      (1<<1)
+#define KS_METADATA_READABLE_Msk  (1<<2)
+#define KS_METADATA_RVK_Msk       (1<<3)
+#define KS_METADATA_SIZE_Pos      (8)
+#define KS_METADATA_SIZE_Msk      (0x1f << KS_METADATA_SIZE_Pos)
+#define KS_METADATA_OWNER_Pos     (16)
+#define KS_METADATA_OWNER_Msk     (0x7 << KS_METADATA_OWNER_Pos)
+#define KS_METADATA_NUMBER_Pos    (20)
+#define KS_METADATA_NUMBER_Msk    (0x3f << KS_METADATA_NUMBER_Pos)
+#define KS_METADATA_DST_Pos       (30)
+#define KS_METADATA_DST_Msk       (0x3 << KS_METADATA_DST_Pos)
+
+#define KS_OWNER_AES              (0ul)
+#define KS_OWNER_HMAC             (1ul)
+#define KS_OWNER_RSA_EXP          (2ul)
+#define KS_OWNER_RSA_MID          (3ul)
+#define KS_OWNER_ECC              (4ul)
+#define KS_OWNER_CPU              (5ul)
+
+#define KS_META_AES               (0ul << KS_METADATA_OWNER_Pos)   /*!< AES Access Only                                */
+#define KS_META_HMAC              (1ul << KS_METADATA_OWNER_Pos)   /*!< HMAC Access Only                               */
+#define KS_META_RSA_EXP           (2ul << KS_METADATA_OWNER_Pos)   /*!< RSA_EXP Access Only                            */
+#define KS_META_RSA_MID           (3ul << KS_METADATA_OWNER_Pos)   /*!< RSA_MID Access Only                            */
+#define KS_META_ECC               (4ul << KS_METADATA_OWNER_Pos)   /*!< ECC Access Only                                */
+#define KS_META_CPU               (5ul << KS_METADATA_OWNER_Pos)   /*!< CPU Access Only                                */
+
+#define KS_META_128               ( 0ul << KS_METADATA_SIZE_Pos)  /*!< Key size 128 bits                              */
+#define KS_META_163               ( 1ul << KS_METADATA_SIZE_Pos)  /*!< Key size 163 bits                              */
+#define KS_META_192               ( 2ul << KS_METADATA_SIZE_Pos)  /*!< Key size 192 bits                              */
+#define KS_META_224               ( 3ul << KS_METADATA_SIZE_Pos)  /*!< Key size 224 bits                              */
+#define KS_META_233               ( 4ul << KS_METADATA_SIZE_Pos)  /*!< Key size 233 bits                              */
+#define KS_META_255               ( 5ul << KS_METADATA_SIZE_Pos)  /*!< Key size 255 bits                              */
+#define KS_META_256               ( 6ul << KS_METADATA_SIZE_Pos)  /*!< Key size 256 bits                              */
+#define KS_META_283               ( 7ul << KS_METADATA_SIZE_Pos)  /*!< Key size 283 bits                              */
+#define KS_META_384               ( 8ul << KS_METADATA_SIZE_Pos)  /*!< Key size 384 bits                              */
+#define KS_META_409               ( 9ul << KS_METADATA_SIZE_Pos)  /*!< Key size 409 bits                              */
+#define KS_META_512               (10ul << KS_METADATA_SIZE_Pos)  /*!< Key size 512 bits                              */
+#define KS_META_521               (11ul << KS_METADATA_SIZE_Pos)  /*!< Key size 521 bits                              */
+#define KS_META_571               (12ul << KS_METADATA_SIZE_Pos)  /*!< Key size 571 bits                              */
+#define KS_META_1024              (16ul << KS_METADATA_SIZE_Pos)  /*!< Key size 1024 bits                             */
+#define KS_META_1536              (17ul << KS_METADATA_SIZE_Pos)  /*!< Key size 1024 bits                             */
+#define KS_META_2048              (18ul << KS_METADATA_SIZE_Pos)  /*!< Key size 2048 bits                             */
+#define KS_META_3072              (19ul << KS_METADATA_SIZE_Pos)  /*!< Key size 1024 bits                             */
+#define KS_META_4096              (20ul << KS_METADATA_SIZE_Pos)  /*!< Key size 4096 bits                             */
+
+#define KS_META_READABLE          (1ul << 2)  /*!< Allow the key to be read by CPU    */
+
+#define KS_TOMETAKEY(x)           (((x) << KS_METADATA_NUMBER_Pos) & KS_METADATA_NUMBER_Msk)
+#define KS_TOKEYIDX(x)            (((x) & KS_METADATA_NUMBER_Msk) >> KS_METADATA_NUMBER_Pos)
+
+
+#define NUA3500_KS_MAGIC         'K'
+
+#define NU_KS_IOCTL_READ         _IOWR(NUA3500_KS_MAGIC, 1, struct ks_read_args *)
+#define NU_KS_IOCTL_WRITE_SRAM   _IOWR(NUA3500_KS_MAGIC, 2, struct ks_write_args *)
+#define NU_KS_IOCTL_WRITE_OTP    _IOWR(NUA3500_KS_MAGIC, 3, struct ks_write_args *)
+#define NU_KS_IOCTL_ERASE        _IOWR(NUA3500_KS_MAGIC, 4, struct ks_kidx_args *)
+#define NU_KS_IOCTL_ERASE_ALL    _IOWR(NUA3500_KS_MAGIC, 5, unsigned long)
+#define NU_KS_IOCTL_REVOKE       _IOWR(NUA3500_KS_MAGIC, 6, struct ks_kidx_args *)
+#define NU_KS_IOCTL_GET_REMAIN   _IOWR(NUA3500_KS_MAGIC, 7, unsigned long)
+
+
+/* type of key */
+#define KS_SRAM                  0x0
+#define KS_OTP                   0x2
+
+
+struct ks_read_args {
+	unsigned int  type;
+	int           key_idx;
+	int           word_cnt;        /* word count of the key                */
+	unsigned int  key[128];
+};
+
+
+
+struct ks_write_args {
+	int           key_idx;
+	unsigned int  meta_data;
+	unsigned int  key[128];
+};
+
+struct ks_kidx_args {
+	unsigned int  type;
+	unsigned int  key_idx;
+};
+
+
+#endif /* __NUA3500_KS_H__ */
-- 
2.0.3

